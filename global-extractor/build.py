import os
import time
import json
import re


# ../extractors/
extractors_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'extractors')
script_dir = os.path.dirname(os.path.realpath(__file__))

addedPlugins = []
pluginList = []

class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'  # Reset to default

def get_functions(allowed_functions=[]):
    # from the extractors directory, get all the files that end with .js
    files = [f for f in os.listdir(extractors_dir) if f.endswith('.js')]
    extractor_functions = {}

    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}üîç SCANNING EXTRACTOR FILES{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"üìÅ Scanning directory: {Colors.BLUE}{extractors_dir}{Colors.END}")
    print(f"üîç Found {Colors.YELLOW}{len(files)}{Colors.END} JavaScript files\n")    # from the files, check if they contain a line with "/* SCHEME START */" and a line with "/* SCHEME END */", if not skip the file
    # for each file with the lines, get the content between the lines and save it to a list
    for file in files:
        with open(os.path.join(extractors_dir, file), 'r', encoding='utf-8') as f:
            content = f.read()
            start = content.find('/* SCHEME START */')
            end = content.find('/* SCHEME END */')
            if start != -1 and end != -1:
                # get the content between the lines
                scheme = content[start + len('/* SCHEME START */'):end]
                # get the function name from the file name
                function_name = file.split('.')[0]
                # check if the function name is in the allowed functions list, if the list is empty, it means all functions are allowed
                if allowed_functions:
                    if function_name not in allowed_functions:
                        print(f"‚ö†Ô∏è  {Colors.YELLOW}Function {function_name} not in allowed list - skipping{Colors.END}")
                        continue
                # add the function to the list
                extractor_functions[function_name] = scheme
                print(f"‚úÖ {Colors.GREEN}Found extractor: {function_name}{Colors.END}")
            else:
                print(f"‚ùå {Colors.RED}Invalid scheme in {file} - missing markers{Colors.END}")
    
    print(f"\n{Colors.CYAN}üìä SCAN RESULTS{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"‚úÖ Valid extractors found: {Colors.GREEN}{len(extractor_functions)}{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")
    return extractor_functions


def build_extractors(functions):
        # create the output file    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}üî® BUILDING EXTRACTORS{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"üì¶ Processing {Colors.YELLOW}{len(functions)}{Colors.END} extractors...")
    
    with open(os.path.join(script_dir, 'output', 'extractors.js'), 'w', encoding='utf-8') as f:
        # write the header
        f.write('/**\n')
        f.write(' * This file is automatically generated.\n')
        f.write(' * Do not edit this file directly.\n')
        f.write(' * \n')
        f.write(' * Build Time: ' + time.strftime('%Y-%m-%d %H:%M:%S') + '\n')
        f.write(' */\n\n')


        
        
        # remove all instances of content between /* REMOVE_START */ and /* REMOVE_END */
        print(f"üßπ {Colors.CYAN}Cleaning up extractor code...{Colors.END}")
        for function_name, scheme in functions.items():
            start = scheme.find('/* REMOVE_START */')
            end = scheme.find('/* REMOVE_END */')
            if start != -1 and end != -1:
                # remove the content between the lines
                scheme = scheme[:start] + scheme[end + len('/* REMOVE_END */'):]
                functions[function_name] = scheme
                print(f"‚úÖ {Colors.GREEN}Removed unwanted code from {function_name}{Colors.END}")

        # Check for duplicate function names and class names
        duplicate_functions = [function for function in functions if list(functions).count(function) > 1]
        
        # Extract class names from all function schemes
        all_class_names = []
        for scheme in functions.values():
            # Find all class names in the scheme
            class_names = [line.split('class ')[1].split(' ')[0] for line in scheme.split('\n') if 'class ' in line]
            all_class_names.extend(class_names)
            
        # Check for duplicate class names
        duplicate_classes = [cls for cls in all_class_names if all_class_names.count(cls) > 1]
        
        # remove duplicates from the list, so there are no duplicates
        duplicate_functions = list(set(duplicate_functions))
        duplicate_classes = list(set(duplicate_classes))
        if duplicate_functions:
            print(f"‚ö†Ô∏è  {Colors.YELLOW}Duplicate function names found: {duplicate_functions}{Colors.END}")
            print(f"üîß {Colors.CYAN}Resolving by removing duplicates...{Colors.END}")
            for function in duplicate_functions:
                # remove the function from the list
                del functions[function]
        if duplicate_classes:
            print(f"‚ö†Ô∏è  {Colors.YELLOW}Duplicate class names found: {duplicate_classes}{Colors.END}")
            print(f"üîß {Colors.CYAN}Resolving by removing duplicates...{Colors.END}")
            for cls in duplicate_classes:
                # remove the class from the list
                for function, scheme in functions.items():
                    if cls in scheme:
                        del functions[function]
                        break
        # check for required plugins
        # e.g. /* {REQUIRED PLUGINS: unpack} */ (plugins are separated by commas)
        for function_name, scheme in functions.items():
            # find the line with /* {REQUIRED PLUGINS: ...} */
            required_plugins_line = re.search(r'/\*\s*\{REQUIRED PLUGINS:\s*([^\}]+)\}\s*\*/', scheme)
            if required_plugins_line:
                required_plugins = required_plugins_line.group(1).strip().split(',')
                # remove whitespace and add to the addedPlugins list
                required_plugins = [plugin.strip() for plugin in required_plugins]
                for plugin in required_plugins:
                    if plugin not in addedPlugins:
                        addedPlugins.append(plugin)
                        print(f"üîå {Colors.CYAN}{function_name} requires plugin: {Colors.YELLOW}{plugin}{Colors.END}")

        
        
                    
        
        # remove double linebreaks
        for function_name, scheme in functions.items():
            functions[function_name] = scheme.replace('\n\n', '\n')

        # write the functions, with a comment above each function with the function name
        for function_name, scheme in functions.items():
            f.write('/* --- ' + function_name + ' --- */\n')
            f.write(scheme + '\n\n')        # save the functions to a json file
        with open(os.path.join(script_dir, 'output', 'extractors.json'), 'w', encoding='utf-8') as json_file:
            json.dump(functions, json_file, indent=4)
        
    print(f"‚úÖ {Colors.GREEN}Extractors built successfully!{Colors.END}")
    print(f"üìÑ Generated: {Colors.BLUE}extractors.js{Colors.END}")
    print(f"üìÑ Generated: {Colors.BLUE}extractors.json{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")

def build_global_extractor(functions, allowed_functions=[]):
    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}üåê BUILDING GLOBAL EXTRACTOR{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"üîß Processing {Colors.YELLOW}{len(functions)}{Colors.END} extractors...")
    
    # get global_extractor_scheme.js
    global_extractor_file = os.path.join(script_dir, 'global_extractor_scheme.js')
    with open(global_extractor_file, 'r', encoding='utf-8') as f:
        content = f.read()        # get version from VERSION file
        version_file = os.path.join(script_dir, 'VERSION.json')
        version = '1.0.0'  # default version
        if os.path.exists(version_file):
            with open(version_file, 'r', encoding='utf-8') as vf:
                version_data = json.load(vf)
                version = version_data["extractor"]
                content = content.replace('{GE VERSION}', version)
                print(f"üìã Version: {Colors.GREEN}{version}{Colors.END}")


        # add header
        header = ''
        header += '/**\n'
        header += ' * @name global_extractor.js\n'
        header += ' * @description A global extractor for various streaming providers to be used in Sora Modules.\n'
        header += ' * @author Cufiy\n'
        header += ' * @url https://github.com/JMcrafter26/sora-global-extractor\n'
        header += ' * @license CUSTOM LICENSE - see https://github.com/JMcrafter26/sora-global-extractor/blob/main/LICENSE\n'
        header += ' * @date ' + time.strftime('%Y-%m-%d %H:%M:%S') + '\n'
        header += ' * @version ' + version + '\n'
        header += ' * @note This file was generated automatically.\n'
        header += ' * The global extractor comes with an auto-updating feature, so you can always get the latest version. https://github.com/JMcrafter26/sora-global-extractor#-auto-updater\n'
        header += ' */\n'
        content = content.replace('/* {HEADER} */', header)
          # get output from the extractors.js file
        print(f"üì¶ {Colors.CYAN}Integrating extractor functions...{Colors.END}")
        with open(os.path.join(script_dir, 'output', 'extractors.js'), 'r', encoding='utf-8') as f:
            extractors_content = f.read()
            # remove the header (the first 5 lines)
            lines = extractors_content.split('\n')
            # remove the first 5 lines
            lines = lines[6:]
            # join the lines
            extractors_content = '\n'.join(lines)


            # replace the /* {EXTRACTOR_FUNCTIONS} */ with the content
            content = content.replace('/* {EXTRACTOR_FUNCTIONS} */', extractors_content)
        




        # replace the {ALL_PROVIDERS} with the provider names separated by a comma
        providers = ', '.join([function for function in functions])
        content = content.replace('/* {ALL_PROVIDERS} */', providers)

        # replace the /* {PLUGINS} */ with the plugins
        if addedPlugins:
            print(f"üîå {Colors.CYAN}Adding required plugins: {Colors.YELLOW}{', '.join(addedPlugins)}{Colors.END}")
            # get file content from plugins directory
            plugins_content = ''
            for plugin in addedPlugins:
                plugin_file = os.path.join(script_dir, 'plugins', plugin + '.js')
                if os.path.exists(plugin_file):
                    with open(plugin_file, 'r', encoding='utf-8') as pf:
                        plugins_content += pf.read() + '\n\n'
                else:
                    print(f"‚ö†Ô∏è  {Colors.YELLOW}Plugin {plugin} not found - skipping{Colors.END}")
            content = content.replace('/* {PLUGINS} */', plugins_content)

        # replace the /* {PROVIDER_CASES} */ like this:
        # case "bigwarp":
        #   return bigwarpExtractor(url);
        # case "speedfiles":
        #   return speedfilesExtractor(url);
        
        print(f"üîó {Colors.CYAN}Generating provider cases...{Colors.END}")
        provider_cases = ''
        for function in functions:
            provider_cases += '    case "' + function + '":\n'
            provider_cases += '      try {\n'
            provider_cases += '         return await ' + function + 'Extractor(html, url);\n'
            provider_cases += '      } catch (error) {\n'
            provider_cases += '         console.log("Error extracting stream URL from ' + function + ':", error);\n'
            provider_cases += '         return null;\n'
            provider_cases += '      }\n'
        content = content.replace('/* {PROVIDER_CASES} */', provider_cases)        # get test/test_providers.txt
        # check if the file exists
        if not os.path.exists(os.path.join(script_dir, 'test', 'test_providers.txt')):
            print(f"‚ö†Ô∏è  {Colors.YELLOW}test/test_providers.txt not found. Skipping test providers.{Colors.END}")
        else:
            print(f"üß™ {Colors.CYAN}Adding test providers...{Colors.END}")
            with open(os.path.join(script_dir, 'test', 'test_providers.txt'), 'r', encoding='utf-8') as f:
                test_providers = f.read().splitlines();
            
            # replace the /* {TEST_PROVIDERS} */ with the test providers, line by line
            test_providers_content = ''
            for provider in test_providers:
                test_providers_content += provider + '\n'
            content = content.replace('/* {TEST_PROVIDERS} */', test_providers_content)

        

        # save file to test/global_extractor_test.js
        with open(os.path.join(script_dir, 'test', 'global_extractor_test.js'), 'w', encoding='utf-8') as f:
            f.write(content)

        # remove TEST SCHEME (/* TEST SCHEME START */)
        start = content.find('/* TEST SCHEME START */')
        end = content.find('/* TEST SCHEME END */')
        if start != -1 and end != -1:
            content = content[:start] + content[end + len('/* TEST SCHEME END */'):]

        # if allowed_functions is empty:
        if allowed_functions:
            print(f"‚úÖ {Colors.GREEN}Building production global extractor...{Colors.END}")
            with open(os.path.join(script_dir, 'output', 'global_extractor.js'), 'w', encoding='utf-8') as f:
                f.write(content)            # also save the file to ../global_extractor.js
            with open(os.path.join(script_dir, '..', 'global_extractor.js'), 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"üìÑ Generated: {Colors.BLUE}global_extractor.js{Colors.END}")
        else:
            print(f"‚ö†Ô∏è  {Colors.YELLOW}Building development global extractor (all extractors)...{Colors.END}")
            # save the file to output/global_extractor.js
            content = '/* WARNING: This file contains all the extractors, working and not working and is not recommended to be used. */\n' + content
            with open(os.path.join(script_dir, 'output', 'global_extractor_all.js'), 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"üìÑ Generated: {Colors.BLUE}global_extractor_all.js{Colors.END}")
        
    print(f"‚úÖ {Colors.GREEN}Global extractor built successfully!{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")
        




def build(allowed_functions=[]):
    if allowed_functions:
        print(f"\n{Colors.CYAN}üéØ BUILDING WITH ALLOWED FUNCTIONS: {Colors.YELLOW}{allowed_functions}{Colors.END}")
    else:
        print(f"\n{Colors.CYAN}üåç BUILDING ALL EXTRACTORS{Colors.END}")

    # get plugins from script directory/plugins there the plugins will be in the format of plugin_name.js
    plugins_dir = os.path.join(script_dir, 'plugins')
    pluginList = []
    for plugin_file in os.listdir(plugins_dir):
        if plugin_file.endswith('.js'):
            pluginList.append(plugin_file[:-3])  # remove .js extension
    print(f"üîå {Colors.CYAN}Available plugins: {Colors.YELLOW}{pluginList}{Colors.END}")

    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}üöÄ GLOBAL EXTRACTOR BUILD STARTED{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    
    # get the functions
    functions = get_functions(allowed_functions)
    # create the output directory if it doesn't exist
    if not os.path.exists(os.path.join(script_dir, 'output')):
        os.makedirs(os.path.join(script_dir, 'output'))
        print(f"üìÅ {Colors.CYAN}Created output directory{Colors.END}")

    try:
        # build the extractors
        build_extractors(functions)
    except Exception as e:
        print(f"‚ùå {Colors.RED}Error building extractors: {str(e)}{Colors.END}")
        return
    
    # try:
    #     # build the global extractor
    #     build_global_extractor(functions)
    # except Exception as e:
    #     print('Error building global extractor: ' + str(e))
    #     return

    build_global_extractor(functions, allowed_functions=allowed_functions)


def test():
    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}üß™ TESTING GLOBAL EXTRACTOR{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"üöÄ {Colors.CYAN}Running test suite...{Colors.END}")
    
    # run test/global_extractor_test.js with node and wait for test/test_results.json (timeout 20s)
    os.system('node ' + os.path.join(script_dir, 'test', 'global_extractor_test.js'))
    # wait for the file to be created
    timeout = 20
    start_time = time.time()
    print(f"‚è≥ {Colors.YELLOW}Waiting for test results... (timeout: {timeout}s){Colors.END}")
    
    while not os.path.exists(os.path.join(script_dir, 'test', 'test_results.json')):
        if time.time() - start_time > timeout:
            print(f"‚ùå {Colors.RED}Timeout waiting for test results.{Colors.END}")
            print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")
            return
        time.sleep(1)
    # read the test results

# {
#   "speedfiles": "passed",
#   "vidmoly": "passed",
#   "filemoon": "failed",
#   "doodstream": "failed",
#   "voe": "passed"
# }

    print(f"üìä {Colors.CYAN}Processing test results...{Colors.END}")
    new_table_content = '<!-- EXTRACTORS_TABLE_START -->\n'
    new_table_content += '| Extractor | Test Passed |\n'
    new_table_content += '| -------- | ------- |\n'
    with open(os.path.join(script_dir, 'test', 'test_results.json'), 'r', encoding='utf-8') as f:
        test_results = json.load(f)
        # based on the test results, update the md table in __file__  '/..' + '/README.md', where <!-- EXTRACTORS_TABLE_START -->
        # and <!-- EXTRACTORS_TABLE_END --> are

        print(f"\n{Colors.CYAN}üìã TEST RESULTS:{Colors.END}")
        passed_count = 0
        failed_count = 0
        for provider, result in test_results.items():
            # use emojis for the results
            if result == 'passed':
                new_table_content += '| ' + provider + ' | ‚úÖ |\n'
                print(f"   ‚úÖ {Colors.GREEN}{provider}: PASSED{Colors.END}")
                passed_count += 1
            else:
                new_table_content += '| ' + provider + ' | ‚ùå |\n'
                print(f"   ‚ùå {Colors.RED}{provider}: FAILED{Colors.END}")
                failed_count += 1


    new_table_content += '\n> **Last updated**: ' + time.strftime('%B %d, %Y') + '\n>\n'
    new_table_content += '> **Test Environment**: Automated CI/CD pipeline with real-world scenarios\n>\n'
    success_rate = (passed_count / (passed_count + failed_count)) * 100 if (passed_count + failed_count) > 0 else 0
    new_table_content += f'> **Success Rate**: {success_rate:.2f}% ({passed_count}/{passed_count + failed_count} extractors passing)\n'

    
    print(f"\n{Colors.CYAN}üìä SUMMARY:{Colors.END}")
    print(f"‚úÖ Passed: {Colors.GREEN}{passed_count}{Colors.END}")
    print(f"‚ùå Failed: {Colors.RED}{failed_count}{Colors.END}")
    
    # read the README.md file
    print(f"üìù {Colors.CYAN}Updating README.md...{Colors.END}")
    with open(os.path.join(script_dir, '..', 'README.md'), 'r', encoding='utf-8') as f:
        readme_content = f.read()
        # find the start and end of the table
        start = readme_content.find('<!-- EXTRACTORS_TABLE_START -->')
        end = readme_content.find('<!-- EXTRACTORS_TABLE_END -->')
        if start == -1 or end == -1:
            print(f"‚ùå {Colors.RED}Error: Table not found in README.md{Colors.END}")
            print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")
            return
        # replace the table with the new table
        new_table_content = readme_content[:start] + new_table_content + readme_content[end:]

    # update the [![Extractors](https://api.jm26.net/b/Extractors-10-orange)](#available-extractors) badge in README.md
    # get it via regex
        badge_pattern = r'\[!\[Extractors\]\(https://api\.jm26\.net/b/Extractors-\d+-orange\)\]\(#available-extractors\)'
        badge_replacement = f"[![Extractors](https://api.jm26.net/b/Extractors-{len(test_results)}-orange)](#available-extractors)"
        new_table_content = re.sub(badge_pattern, badge_replacement, new_table_content)
    
        # write the file
        with open(os.path.join(script_dir, '..', 'README.md'), 'w', encoding='utf-8') as f:
            f.write(new_table_content)
            print(f"‚úÖ {Colors.GREEN}README.md updated successfully!{Colors.END}")
    

    
    
    print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")
    return test_results



if __name__ == "__main__":
    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}üöÄ SORA GLOBAL EXTRACTOR BUILD SYSTEM{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    
    # build the extractors
    startTime = time.time()
    build()
    print(f"\nüéâ {Colors.GREEN}Build completed successfully!{Colors.END}")

    test_results = test()
    print(f"üß™ {Colors.GREEN}Test completed successfully!{Colors.END}")

    allowed_functions = []
    # add the passed extractors to the allowed functions
    for provider, result in test_results.items():
        if result == 'passed':
            allowed_functions.append(provider)
    
    # build the global extractor again with the allowed functions
    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}üéØ BUILDING PRODUCTION VERSION{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"üîß {Colors.CYAN}Building global extractor with {Colors.GREEN}{len(allowed_functions)}{Colors.CYAN} working extractors...{Colors.END}")
    build(allowed_functions=allowed_functions)

    endTime = time.time()
    print(f"\n{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"{Colors.CYAN}‚úÖ BUILD PROCESS COMPLETED{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}")
    print(f"‚è±Ô∏è  Total time taken: {Colors.GREEN}{str(round(endTime - startTime, 2))} seconds{Colors.END}")
    print(f"üì¶ Working extractors: {Colors.GREEN}{len(allowed_functions)}{Colors.END}")
    print(f"üéâ {Colors.GREEN}All done!{Colors.END}")
    print(f"{Colors.CYAN}{'='*60}{Colors.END}\n")