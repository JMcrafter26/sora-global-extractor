import os
import time
import json

# ../extractors/
extractors_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'extractors')
script_dir = os.path.dirname(os.path.realpath(__file__))
extractor_functions = {}

def get_functions():
    # from the extractors directory, get all the files that end with .js
    files = [f for f in os.listdir(extractors_dir) if f.endswith('.js')]

    print('Getting functions from files...')

    # from the files, check if they contain a line with "/* SCHEME START */" and a line with "/* SCHEME END */", if not skip the file
    # for each file with the lines, get the content between the lines and save it to a list
    for file in files:
        with open(os.path.join(extractors_dir, file), 'r') as f:
            content = f.read()
            start = content.find('/* SCHEME START */')
            end = content.find('/* SCHEME END */')
            if start != -1 and end != -1:
                # get the content between the lines
                scheme = content[start + len('/* SCHEME START */'):end]
                # get the function name from the file name
                function_name = file.split('.')[0]
                # add the function to the list
                extractor_functions[function_name] = scheme
    
    print(len(extractor_functions), 'functions found.')
    return extractor_functions


def build_extractors(functions):
        # create the output file

    print('Building extractors...')
    with open(os.path.join(script_dir, 'output', 'extractors.js'), 'w') as f:
        # write the header
        f.write('/**\n')
        f.write(' * This file is automatically generated.\n')
        f.write(' * Do not edit this file directly.\n')
        f.write(' * \n')
        f.write(' * Build Time: ' + time.strftime('%Y-%m-%d %H:%M:%S') + '\n')
        f.write(' */\n\n')

        # if it contains duplicate function names, add a warning
        duplicate_functions = [function for function in functions if list(functions).count(function) > 1]
        if duplicate_functions:
            f.write('/* WARNING: Duplicate function names found: ' + str(duplicate_functions) + ' */\n\n')
            print('WARNING: Duplicate function names found: ' + str(duplicate_functions))
        
        # remove double linebreaks
        for function_name, scheme in functions.items():
            functions[function_name] = scheme.replace('\n\n', '\n')

        # write the functions, with a comment above each function with the function name
        for function_name, scheme in functions.items():
            f.write('/* --- ' + function_name + ' --- */\n')
            f.write(scheme + '\n\n')

        # save the functions to a json file
        with open(os.path.join(script_dir, 'output', 'extractors.json'), 'w') as json_file:
            json.dump(functions, json_file, indent=4)
        print('Extractors built successfully.')

def build_global_extractor(functions):
    print('Building global extractor...')
    # get global_extractor_scheme.js
    global_extractor_file = os.path.join(script_dir, 'global_extractor_scheme.js')
    with open(global_extractor_file, 'r') as f:
        content = f.read()

        # add header
        header = '/* Replace your extractStreamUrl function with the script below */\n\n'
        header += '/**\n'
        header += ' * @name global_extractor.js\n'
        header += ' * @description Global extractor to be used in Sora Modules\n'
        header += ' * @author Cufiy\n'
        header += ' * @license MIT\n'
        header += ' * @date ' + time.strftime('%Y-%m-%d %H:%M:%S') + '\n'
        header += ' * @note This file is automatically generated. Do not edit this file directly.\n'
        header += ' */\n'
        content = content.replace('/* {HEADER} */', header)
        
        # get output from the extractors.js file
        with open(os.path.join(script_dir, 'output', 'extractors.js'), 'r') as f:
            extractors_content = f.read()
            # remove the header (the first 5 lines)
            lines = extractors_content.split('\n')
            # remove the first 5 lines
            lines = lines[6:]
            # join the lines
            extractors_content = '\n'.join(lines)
            # replace the /* {EXTRACTOR_FUNCTIONS} */ with the content
            content = content.replace('/* {EXTRACTOR_FUNCTIONS} */', extractors_content)



        # replace the {ALL_PROVIDERS} with the provider names separated by a comma
        providers = ', '.join([function for function in functions])
        content = content.replace('/* {ALL_PROVIDERS} */', providers)

        # replace the /* {PROVIDER_CASES} */ like this:
        # case "bigwarp":
        #   return bigwarpExtractor(url);
        # case "speedfiles":
        #   return speedfilesExtractor(url);
        
        provider_cases = ''
        for function in functions:
            provider_cases += '    case "' + function + '":\n'
            provider_cases += '      return await ' + function + 'Extractor(html);\n'
        content = content.replace('/* {PROVIDER_CASES} */', provider_cases)


        # save file to test/global_extractor_test.js
        with open(os.path.join(script_dir, 'test', 'global_extractor_test.js'), 'w') as f:
            f.write(content)

        # remove TESR SCHEME (/* TEST SCHEME START */)
        start = content.find('/* TEST SCHEME START */')
        end = content.find('/* TEST SCHEME END */')
        if start != -1 and end != -1:
            content = content[:start] + content[end + len('/* TEST SCHEME END */'):]

        # write the file
        with open(os.path.join(script_dir, 'output', 'global_extractor.js'), 'w') as f:
            f.write(content)




def build():
    print('Global extractor build started...')
    # get the functions
    functions = get_functions()
    # create the output directory if it doesn't exist
    if not os.path.exists(os.path.join(script_dir, 'output')):
        os.makedirs(os.path.join(script_dir, 'output'))

    try:
        # build the extractors
        build_extractors(functions)
    except Exception as e:
        print('Error building extractors: ' + str(e))
        return
    
    # try:
    #     # build the global extractor
    #     build_global_extractor(functions)
    # except Exception as e:
    #     print('Error building global extractor: ' + str(e))
    #     return

    build_global_extractor(functions)
    


    
        



    




if __name__ == "__main__":
    # build the extractors
    build()
    print("Extractors built successfully.")