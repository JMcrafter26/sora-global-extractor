{
    "bigwarp": "\n/**\n * \n * @name bigWarpExtractor\n * @author Cufiy\n */\nasync function bigwarpExtractor(videoPage, url = null) {\n\n  // regex get 'sources: [{file:\"THIS_IS_THE_URL\" ... '\n  const scriptRegex = /sources:\\s*\\[\\{file:\"([^\"]+)\"/;\n  // const scriptRegex =\n  const scriptMatch = scriptRegex.exec(videoPage);\n  const bwDecoded = scriptMatch ? scriptMatch[1] : false;\n  console.log(\"BigWarp HD Decoded:\", bwDecoded);\n  return bwDecoded;\n}\n",
    "doodstream": "\n/**\n * @name doodstreamExtractor\n * @author Cufiy\n */\nasync function doodstreamExtractor(html, url = null) {\n    console.log(\"DoodStream extractor called\");\n    console.log(\"DoodStream extractor URL: \" + url);\n        const streamDomain = url.match(/https:\\/\\/(.*?)\\//, url)[0].slice(8, -1);\n        const md5Path = html.match(/'\\/pass_md5\\/(.*?)',/, url)[0].slice(11, -2);\n        const token = md5Path.substring(md5Path.lastIndexOf(\"/\") + 1);\n        const expiryTimestamp = new Date().valueOf();\n        const random = randomStr(10);\n\n        const passResponse = await fetch(`https://${streamDomain}/pass_md5/${md5Path}`, {\n            headers: {\n                \"Referer\": url,\n            },\n        });\n        console.log(\"DoodStream extractor response: \" + passResponse.status);\n        const responseData = await passResponse.text();\n        const videoUrl = `${responseData}${random}?token=${token}&expiry=${expiryTimestamp}`;\n        console.log(\"DoodStream extractor video URL: \" + videoUrl);\n        return videoUrl;\n}\nfunction randomStr(length) {\n    const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * characters.length));\n    }\n    return result;\n}\n",
    "filemoon": "\n/**\n * @name filemoonExtractor\n * @author Cufiy - Inspired by Churly\n */\nasync function filemoonExtractor(html, url = null) {\n    // check if contains iframe, if does, extract the src and get the url\n    const regex = /<iframe[^>]+src=\"([^\"]+)\"[^>]*><\\/iframe>/;\n    const match = html.match(regex);\n    if (match) {\n        const iframeUrl = match[1];\n        const response = await fetch(iframeUrl);\n        html = await response.text();\n    }\n    // get /<script[^>]*>([\\s\\S]*?)<\\/script>/gi\n    const scriptRegex = /<script[^>]*>([\\s\\S]*?)<\\/script>/gi;\n    const scripts = [];\n    let scriptMatch;\n    while ((scriptMatch = scriptRegex.exec(html)) !== null) {\n        scripts.push(scriptMatch[1]);\n    }\n    // get the script with eval and m3u8\n    const evalRegex = /eval\\((.*?)\\)/;\n    const m3u8Regex = /m3u8/;\n    const evalScript = scripts.find(script => evalRegex.test(script) && m3u8Regex.test(script));\n    if (!evalScript) {\n        console.log(\"No eval script found\");\n        return null;\n    }\n    const unpackedScript = unpack(evalScript);\n    // get the m3u8 url\n    const m3u8Regex2 = /https?:\\/\\/[^\\s]+master\\.m3u8[^\\s]*?(\\?[^\"]*)?/;\n    const m3u8Match = unpackedScript.match(m3u8Regex2);\n    if (m3u8Match) {\n        return m3u8Match[0];\n    } else {\n        console.log(\"No M3U8 URL found\");\n        return null;\n    }\n}\nclass Unbaser {\n    constructor(base) {\n        this.ALPHABET = {\n            62: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n            95: \"' !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'\",\n        };\n        this.dictionary = {};\n        this.base = base;\n        if (36 < base && base < 62) {\n            this.ALPHABET[base] = this.ALPHABET[base] ||\n                this.ALPHABET[62].substr(0, base);\n        }\n        if (2 <= base && base <= 36) {\n            this.unbase = (value) => parseInt(value, base);\n        }\n        else {\n            try {\n                [...this.ALPHABET[base]].forEach((cipher, index) => {\n                    this.dictionary[cipher] = index;\n                });\n            }\n            catch (er) {\n                throw Error(\"Unsupported base encoding.\");\n            }\n            this.unbase = this._dictunbaser;\n        }\n    }\n    _dictunbaser(value) {\n        let ret = 0;\n        [...value].reverse().forEach((cipher, index) => {\n            ret = ret + ((Math.pow(this.base, index)) * this.dictionary[cipher]);\n        });\n        return ret;\n    }\n}\n\nfunction unpack(source) {\n    let { payload, symtab, radix, count } = _filterargs(source);\n    if (count != symtab.length) {\n        throw Error(\"Malformed p.a.c.k.e.r. symtab.\");\n    }\n    let unbase;\n    try {\n        unbase = new Unbaser(radix);\n    }\n    catch (e) {\n        throw Error(\"Unknown p.a.c.k.e.r. encoding.\");\n    }\n    function lookup(match) {\n        const word = match;\n        let word2;\n        if (radix == 1) {\n            word2 = symtab[parseInt(word)];\n        }\n        else {\n            word2 = symtab[unbase.unbase(word)];\n        }\n        return word2 || word;\n    }\n    source = payload.replace(/\\b\\w+\\b/g, lookup);\n    return _replacestrings(source);\n    function _filterargs(source) {\n        const juicers = [\n            /}\\('(.*)', *(\\d+|\\[\\]), *(\\d+), *'(.*)'\\.split\\('\\|'\\), *(\\d+), *(.*)\\)\\)/,\n            /}\\('(.*)', *(\\d+|\\[\\]), *(\\d+), *'(.*)'\\.split\\('\\|'\\)/,\n        ];\n        for (const juicer of juicers) {\n            const args = juicer.exec(source);\n            if (args) {\n                let a = args;\n                if (a[2] == \"[]\") {\n                }\n                try {\n                    return {\n                        payload: a[1],\n                        symtab: a[4].split(\"|\"),\n                        radix: parseInt(a[2]),\n                        count: parseInt(a[3]),\n                    };\n                }\n                catch (ValueError) {\n                    throw Error(\"Corrupted p.a.c.k.e.r. data.\");\n                }\n            }\n        }\n        throw Error(\"Could not make sense of p.a.c.k.e.r data (unexpected code structure)\");\n    }\n    function _replacestrings(source) {\n        return source;\n    }\n}\n",
    "mp4upload": "\n/**\n * @name mp4uploadExtractor\n * @author Cufiy\n */\nasync function mp4uploadExtractor(html, url = null) {\n    // src: \"https://a4.mp4upload.com:183/d/xkx3b4etz3b4quuo66rbmyqtjjoivahfxp27f35pti45rzapbvj5xwb4wuqtlpewdz4dirfp/video.mp4\"  \n    const regex = /src:\\s*\"([^\"]+)\"/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for mp4upload extractor\");\n    return null;\n  }\n}\n",
    "speedfiles": "\n/**\n * @name speedfilesExtractor\n * @author Cufiy\n */\nfunction speedfilesExtractor(sourcePageHtml) {\n  // get var _0x5opu234 = \"THIS_IS_AN_ENCODED_STRING\"\n  const REGEX = /var\\s+_0x5opu234\\s*=\\s*\"([^\"]+)\"/;\n  const match = sourcePageHtml.match(REGEX);\n  if (match == null || match[1] == null) {\n    console.log(\"Could not extract from Speedfiles source\");\n    return null;\n  }\n  const encodedString = match[1];\n  console.log(\"Encoded String:\" + encodedString);\n  // Step 1: Base64 decode the initial string\n  let step1 = atob(encodedString);\n  // Step 2: Swap character cases and reverse\n  let step2 = step1\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step3 = step2.split(\"\").reverse().join(\"\");\n  // Step 3: Base64 decode again and reverse\n  let step4 = atob(step3);\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 4: Hex decode pairs\n  let step6 = \"\";\n  for (let i = 0; i < step5.length; i += 2) {\n    step6 += String.fromCharCode(parseInt(step5.substr(i, 2), 16));\n  }\n  // Step 5: Subtract 3 from character codes\n  let step7 = step6\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - 3))\n    .join(\"\");\n  // Step 6: Final case swap, reverse, and Base64 decode\n  let step8 = step7\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step9 = step8.split(\"\").reverse().join(\"\");\n  // return atob(step9);\n  let decodedUrl = atob(step9);\n  return decodedUrl;\n}\n",
    "turbovid": "\n/**\n * @name turbovidExtractor\n * @author Cufiy\n */\nasync function turbovidExtractor(html, url = null) {\n  const embedUrl = url;\n  // 1. Extract critical variables from embed page\n  const { mediaType, apKey, xxId } = await extractEmbedVariables(html);\n  console.log(\n    \"mediaType:\" + mediaType + \" | apKey:\" + apKey + \" | xxId:\" + xxId\n  );\n  // 2. Get decryption keys\n  const juiceKeys = await fetchJuiceKeys(embedUrl);\n  console.log(\"juiceKeys: \" + juiceKeys.juice);\n  // 3. Get encrypted video payload\n  const encryptedPayload = await fetchEncryptedPayload(embedUrl, apKey, xxId);\n \n  // 4. Decrypt and return final url\n  const streamUrl = xorDecryptHex(encryptedPayload, juiceKeys.juice);\n  console.log(\"streamUrl: \" + streamUrl);\n  // 5. Return the final stream URL\n  return streamUrl;\n}\n//   HELPERS\nasync function extractEmbedVariables(html) {\n  return {\n    mediaType: getJsVarValue(html, \"media_type\"),\n    // posterPath: getJsVarValue(html, 'posterPath'),\n    apKey: getJsVarValue(html, \"apkey\"),\n    dKey: getJsVarValue(html, \"dakey\"),\n    xxId: getJsVarValue(html, \"xxid\"),\n    xyId: getJsVarValue(html, \"xyid\"),\n  };\n}\nfunction getJsVarValue(html, varName) {\n  const regex = new RegExp(`const ${varName}\\\\s*=\\\\s*\"([^\"]+)`);\n  const match = html.match(regex);\n  return match ? match[1] : null;\n}\nasync function fetchJuiceKeys(embedUrl) {\n  // console.log(\"fetchJuiceKeys called with embedUrl:\", embedUrl);\n  // const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;\n  const fetchUrl =\n    atob(\"aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==\") + \"juice_key\";\n  // const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${fetchUrl}&headers=${headers} }`;\n  // const response = await fetch(vercelUrl);\n  const response = await fetch(fetchUrl, {\n    headers: {\n      method: \"GET\",\n      referer: embedUrl,\n    },\n  });\n  console.log(\"fetchJuiceKeys response:\", response.status);\n  // save entire response to file  \n  return await response.json() || await JSON.parse(response);\n}\nasync function fetchEncryptedPayload(embedUrl, apKey, xxId) {\n  const url =\n    atob(\"aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==\") +\n    \"the_juice_v2/?\" +\n    apKey +\n    \"=\" +\n    xxId;\n  console.log(\"url:\", url);\n  // const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;\n  // const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${url}&headers=${headers} }`;\n  // const response = await fetch(vercelUrl);\n  const response = await fetch(url, {\n    headers: {\n      method: \"GET\",\n      referer: embedUrl,\n    },\n  });\n  console.log(\"fetchEncryptedPayload response:\", response.status);\n  const data = await response.json() || await JSON.parse(response);\n  return data.data;\n}\nfunction xorDecryptHex(hexData, key) {\n  if (!hexData) {\n    throw new Error(\"hexData is undefined or null\");\n  }\n  const buffer = new Uint8Array(\n    hexData\n      .toString()\n      .match(/../g)\n      .map((h) => parseInt(h, 16))\n  );\n  let decrypted = \"\";\n  for (let i = 0; i < buffer.length; i++) {\n    const keyByte = key.charCodeAt(i % key.length);\n    decrypted += String.fromCharCode(buffer[i] ^ keyByte);\n  }\n  return decrypted;\n}\n",
    "vidmoly": "\n/**\n * @name vidmolyExtractor\n * @author Ibro\n */\nasync function vidmolyExtractor(html, url = null) {\n  const regexSub = /<option value=\"([^\"]+)\"[^>]*>\\s*SUB - Omega\\s*<\\/option>/;\n  const regexFallback = /<option value=\"([^\"]+)\"[^>]*>\\s*Omega\\s*<\\/option>/;\n  const fallback =\n    /<option value=\"([^\"]+)\"[^>]*>\\s*SUB v2 - Omega\\s*<\\/option>/;\n  let match =\n    html.match(regexSub) || html.match(regexFallback) || html.match(fallback);\n  if (match) {\n    const decodedHtml = atob(match[1]); // Decode base64\n    const iframeMatch = decodedHtml.match(/<iframe\\s+src=\"([^\"]+)\"/);\n    if (!iframeMatch) {\n      console.log(\"Vidmoly extractor: No iframe match found\");\n      return null;\n    }\n    const streamUrl = iframeMatch[1].startsWith(\"//\")\n      ? \"https:\" + iframeMatch[1]\n      : iframeMatch[1];\n    const responseTwo = await fetchv2(streamUrl);\n    const htmlTwo = await responseTwo.text();\n    const m3u8Match = htmlTwo.match(/sources:\\s*\\[\\{file:\"([^\"]+\\.m3u8)\"/);\n    return m3u8Match ? m3u8Match[1] : null;\n  } else {\n    console.log(\"Vidmoly extractor: No match found, using fallback\");\n    //  regex the sources: [{file:\"this_is_the_link\"}]\n    const sourcesRegex = /sources:\\s*\\[\\{file:\"(https?:\\/\\/[^\"]+)\"\\}/;\n    const sourcesMatch = html.match(sourcesRegex);\n    let sourcesString = sourcesMatch\n      ? sourcesMatch[1].replace(/'/g, '\"')\n      : null;\n    return sourcesString;\n  }\n}\n",
    "vidoza": "\n/**\n * @name vidozaExtractor\n * @author Cufiy\n */\nasync function vidozaExtractor(html, url = null) {\n  const regex = /<source src=\"([^\"]+)\" type='video\\/mp4'>/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for vidoza extractor\");\n    return null;\n  }\n}\n",
    "voe": "\n/**\n * @name voeExtractor\n * @author Cufiy\n */\nfunction voeExtractor(html, url = null) {\n// Extract the first <script type=\"application/json\">...</script>\n    const jsonScriptMatch = html.match(\n      /<script[^>]+type=[\"']application\\/json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i\n    );\n    if (!jsonScriptMatch) {\n      console.log(\"No application/json script tag found\");\n      return null;\n    }\n\n    const obfuscatedJson = jsonScriptMatch[1].trim();\n  let data;\n  try {\n    data = JSON.parse(obfuscatedJson);\n  } catch (e) {\n    throw new Error(\"Invalid JSON input.\");\n  }\n  if (!Array.isArray(data) || typeof data[0] !== \"string\") {\n    throw new Error(\"Input doesn't match expected format.\");\n  }\n  let obfuscatedString = data[0];\n  // Step 1: ROT13\n  let step1 = voeRot13(obfuscatedString);\n  // Step 2: Remove patterns\n  let step2 = voeRemovePatterns(step1);\n  // Step 3: Base64 decode\n  let step3 = voeBase64Decode(step2);\n  // Step 4: Subtract 3 from each char code\n  let step4 = voeShiftChars(step3, 3);\n  // Step 5: Reverse string\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 6: Base64 decode again\n  let step6 = voeBase64Decode(step5);\n  // Step 7: Parse as JSON\n  let result;\n  try {\n    result = JSON.parse(step6);\n  } catch (e) {\n    throw new Error(\"Final JSON parse error: \" + e.message);\n  }\n  // console.log(\"Decoded JSON:\", result);\n  // check if direct_access_url is set, not null and starts with http\n  if (result && typeof result === \"object\") {\n    const streamUrl =\n      result.direct_access_url ||\n      result.source\n        .map((source) => source.direct_access_url)\n        .find((url) => url && url.startsWith(\"http\"));\n    if (streamUrl) {\n      console.log(\"Voe Stream URL: \" + streamUrl);\n      return streamUrl;\n    } else {\n      console.log(\"No stream URL found in the decoded JSON\");\n    }\n  }\n  return result;\n}\nfunction voeRot13(str) {\n  return str.replace(/[a-zA-Z]/g, function (c) {\n    return String.fromCharCode(\n      (c <= \"Z\" ? 90 : 122) >= (c = c.charCodeAt(0) + 13)\n        ? c\n        : c - 26\n    );\n  });\n}\nfunction voeRemovePatterns(str) {\n  const patterns = [\"@$\", \"^^\", \"~@\", \"%?\", \"*~\", \"!!\", \"#&\"];\n  let result = str;\n  for (const pat of patterns) {\n    result = result.split(pat).join(\"\");\n  }\n  return result;\n}\nfunction voeBase64Decode(str) {\n  // atob is available in browsers and Node >= 16\n  if (typeof atob === \"function\") {\n    return atob(str);\n  }\n  // Node.js fallback\n  return Buffer.from(str, \"base64\").toString(\"utf-8\");\n}\nfunction voeShiftChars(str, shift) {\n  return str\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - shift))\n    .join(\"\");\n}\n"
}