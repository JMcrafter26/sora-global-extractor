{
    "bigwarp": "\n/**\n * \n * @name bigWarpExtractor\n * @author Cufiy\n */\nasync function bigwarpExtractor(videoPage, url = null) {\n\n  // regex get 'sources: [{file:\"THIS_IS_THE_URL\" ... '\n  const scriptRegex = /sources:\\s*\\[\\{file:\"([^\"]+)\"/;\n  // const scriptRegex =\n  const scriptMatch = scriptRegex.exec(videoPage);\n  const bwDecoded = scriptMatch ? scriptMatch[1] : false;\n  console.log(\"BigWarp HD Decoded:\", bwDecoded);\n  return bwDecoded;\n}\n",
    "doodstream": "\n/**\n * @name doodstreamExtractor\n * @author Cufiy\n */\nasync function doodstreamExtractor(html, url = null) {\n    console.log(\"DoodStream extractor called\");\n    console.log(\"DoodStream extractor URL: \" + url);\n    const doodhost = url.match(/https:\\/\\/(.*?)\\//, url)[0].slice(8, -1);\n    const md5 = html.match(/'\\/pass_md5\\/(.*?)',/, url)[0].slice(11, -2);\n    const token = md5.substring(md5.lastIndexOf(\"/\") + 1);\n    const expiry = new Date().valueOf();\n    const randomString = getRandomString(10);\n    response = await fetch(`https://${doodhost}/pass_md5/${md5}`, {\n        headers: {\n            \"Referer\": url,\n        },\n    });\n    console.log(\"DoodStream extractor response: \" + response.status);\n    const body = await response.text();\n    const videoUrl = `${body}${randomString}?token=${token}&expiry=${expiry}`;\n    console.log(\"DoodStream extractor video URL: \" + videoUrl);\n    return videoUrl;\n}\nfunction getRandomString(length) {\n    const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * characters.length));\n    }\n    return result;\n}\n",
    "speedfiles": "\n/**\n * @name speedfilesExtractor\n * @author Cufiy\n */\nfunction speedfilesExtractor(sourcePageHtml) {\n  // get var _0x5opu234 = \"THIS_IS_AN_ENCODED_STRING\"\n  const REGEX = /var\\s+_0x5opu234\\s*=\\s*\"([^\"]+)\"/;\n  const match = sourcePageHtml.match(REGEX);\n  if (match == null || match[1] == null) {\n    console.log(\"Could not extract from Speedfiles source\");\n    return null;\n  }\n  const encodedString = match[1];\n  console.log(\"Encoded String:\" + encodedString);\n  // Step 1: Base64 decode the initial string\n  let step1 = atob(encodedString);\n  // Step 2: Swap character cases and reverse\n  let step2 = step1\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step3 = step2.split(\"\").reverse().join(\"\");\n  // Step 3: Base64 decode again and reverse\n  let step4 = atob(step3);\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 4: Hex decode pairs\n  let step6 = \"\";\n  for (let i = 0; i < step5.length; i += 2) {\n    step6 += String.fromCharCode(parseInt(step5.substr(i, 2), 16));\n  }\n  // Step 5: Subtract 3 from character codes\n  let step7 = step6\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - 3))\n    .join(\"\");\n  // Step 6: Final case swap, reverse, and Base64 decode\n  let step8 = step7\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step9 = step8.split(\"\").reverse().join(\"\");\n  // return atob(step9);\n  let decodedUrl = atob(step9);\n  return decodedUrl;\n}\n",
    "turbovid": "\n/**\n * @name turbovidExtractor\n * @author Cufiy\n */\nasync function turbovidExtractor(html, url = null) {\n  const base64EmbedUrl = html.match(/main_origin = \"([^\"]+)\"/)[1];\n  const embedUrl = atob(base64EmbedUrl);\n  // 1. Extract critical variables from embed page\n  const { mediaType, apKey, xxId } = await extractEmbedVariables(embedUrl);\n  console.log(\n    \"mediaType:\" + mediaType + \" | apKey:\" + apKey + \" | xxId:\" + xxId\n  );\n  // 2. Get decryption keys\n  const juiceKeys = await fetchJuiceKeys(embedUrl);\n  console.log(\"juiceKeys: \" + juiceKeys.juice);\n  // 3. Get encrypted video payload\n  const encryptedPayload = await fetchEncryptedPayload(embedUrl, apKey, xxId);\n \n  // 4. Decrypt and return final url\n  const streamUrl = xorDecryptHex(encryptedPayload, juiceKeys.juice);\n  console.log(\"streamUrl: \" + streamUrl);\n  // 5. Return the final stream URL\n  if (mediaType === \"video\") {\n    return streamUrl;\n  } else {\n    console.log(\"Media type is not video\");\n    return null;\n  }\n}\n//   HELPERS\nasync function extractEmbedVariables(embedUrl) {\n  const response = await fetch(embedUrl);\n  // const html = await response.text();\n  const html = await response;\n  return {\n    mediaType: getJsVarValue(html, \"media_type\"),\n    // posterPath: getJsVarValue(html, 'posterPath'),\n    apKey: getJsVarValue(html, \"apkey\"),\n    dKey: getJsVarValue(html, \"dakey\"),\n    xxId: getJsVarValue(html, \"xxid\"),\n    xyId: getJsVarValue(html, \"xyid\"),\n  };\n}\nasync function fetchJuiceKeys(embedUrl) {\n  const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;\n  const fetchUrl =\n    atob(\"aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==\") + \"juice_key\";\n  const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${fetchUrl}&headers=${headers} }`;\n  const response = await fetch(vercelUrl);\n  return await JSON.parse(response);\n}\nasync function fetchEncryptedPayload(embedUrl, apKey, xxId) {\n  const url =\n    atob(\"aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==\") +\n    \"the_juice_v2/?\" +\n    apKey +\n    \"=\" +\n    xxId;\n  console.log(\"url:\", url);\n  const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;\n  const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${url}&headers=${headers} }`;\n  const response = await fetch(vercelUrl);\n  const data = await JSON.parse(response);\n  return data.data;\n}\nfunction xorDecryptHex(hexData, key) {\n  if (!hexData) {\n    throw new Error(\"hexData is undefined or null\");\n  }\n  const buffer = new Uint8Array(\n    hexData\n      .toString()\n      .match(/../g)\n      .map((h) => parseInt(h, 16))\n  );\n  let decrypted = \"\";\n  for (let i = 0; i < buffer.length; i++) {\n    const keyByte = key.charCodeAt(i % key.length);\n    decrypted += String.fromCharCode(buffer[i] ^ keyByte);\n  }\n  return decrypted;\n}\n",
    "vidmoly": "\n/**\n * @name vidmolyExtractor\n * @author Ibro\n */\nasync function vidmolyExtractor(html, url = null) {\n  const regexSub = /<option value=\"([^\"]+)\"[^>]*>\\s*SUB - Omega\\s*<\\/option>/;\n  const regexFallback = /<option value=\"([^\"]+)\"[^>]*>\\s*Omega\\s*<\\/option>/;\n  const fallback =\n    /<option value=\"([^\"]+)\"[^>]*>\\s*SUB v2 - Omega\\s*<\\/option>/;\n  let match =\n    html.match(regexSub) || html.match(regexFallback) || html.match(fallback);\n  if (match) {\n    const decodedHtml = atob(match[1]); // Decode base64\n    const iframeMatch = decodedHtml.match(/<iframe\\s+src=\"([^\"]+)\"/);\n    if (!iframeMatch) {\n      console.log(\"Vidmoly extractor: No iframe match found\");\n      return null;\n    }\n    const streamUrl = iframeMatch[1].startsWith(\"//\")\n      ? \"https:\" + iframeMatch[1]\n      : iframeMatch[1];\n    const responseTwo = await fetchv2(streamUrl);\n    const htmlTwo = await responseTwo.text();\n    const m3u8Match = htmlTwo.match(/sources:\\s*\\[\\{file:\"([^\"]+\\.m3u8)\"/);\n    return m3u8Match ? m3u8Match[1] : null;\n  } else {\n    console.log(\"Vidmoly extractor: No match found, using fallback\");\n    //  regex the sources: [{file:\"this_is_the_link\"}]\n    const sourcesRegex = /sources:\\s*\\[\\{file:\"(https?:\\/\\/[^\"]+)\"\\}/;\n    const sourcesMatch = html.match(sourcesRegex);\n    let sourcesString = sourcesMatch\n      ? sourcesMatch[1].replace(/'/g, '\"')\n      : null;\n    return sourcesString;\n  }\n}\n"
}