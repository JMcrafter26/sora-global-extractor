{
    "doodstream": "\n/**\n * @name doodstreamExtractor\n * @author Cufiy\n */\nasync function doodstreamExtractor(html, url = null) {\n    console.log(\"DoodStream extractor called\");\n    console.log(\"DoodStream extractor URL: \" + url);\n        const streamDomain = url.match(/https:\\/\\/(.*?)\\//, url)[0].slice(8, -1);\n        const md5Path = html.match(/'\\/pass_md5\\/(.*?)',/, url)[0].slice(11, -2);\n        const token = md5Path.substring(md5Path.lastIndexOf(\"/\") + 1);\n        const expiryTimestamp = new Date().valueOf();\n        const random = randomStr(10);\n        const passResponse = await fetch(`https://${streamDomain}/pass_md5/${md5Path}`, {\n            headers: {\n                \"Referer\": url,\n            },\n        });\n        console.log(\"DoodStream extractor response: \" + passResponse.status);\n        const responseData = await passResponse.text();\n        const videoUrl = `${responseData}${random}?token=${token}&expiry=${expiryTimestamp}`;\n        console.log(\"DoodStream extractor video URL: \" + videoUrl);\n        return videoUrl;\n}\nfunction randomStr(length) {\n    const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * characters.length));\n    }\n    return result;\n}\n",
    "mp4upload": "\n/**\n * @name mp4uploadExtractor\n * @author Cufiy\n */\nasync function mp4uploadExtractor(html, url = null) {\n    // src: \"https://a4.mp4upload.com:183/d/xkx3b4etz3b4quuo66rbmyqtjjoivahfxp27f35pti45rzapbvj5xwb4wuqtlpewdz4dirfp/video.mp4\"  \n    const regex = /src:\\s*\"([^\"]+)\"/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for mp4upload extractor\");\n    return null;\n  }\n}\n",
    "speedfiles": "\n/**\n * @name speedfilesExtractor\n * @author Cufiy\n */\nfunction speedfilesExtractor(sourcePageHtml) {\n  // get var _0x5opu234 = \"THIS_IS_AN_ENCODED_STRING\"\n  const REGEX = /var\\s+_0x5opu234\\s*=\\s*\"([^\"]+)\"/;\n  const match = sourcePageHtml.match(REGEX);\n  if (match == null || match[1] == null) {\n    console.log(\"Could not extract from Speedfiles source\");\n    return null;\n  }\n  const encodedString = match[1];\n  console.log(\"Encoded String:\" + encodedString);\n  // Step 1: Base64 decode the initial string\n  let step1 = atob(encodedString);\n  // Step 2: Swap character cases and reverse\n  let step2 = step1\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step3 = step2.split(\"\").reverse().join(\"\");\n  // Step 3: Base64 decode again and reverse\n  let step4 = atob(step3);\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 4: Hex decode pairs\n  let step6 = \"\";\n  for (let i = 0; i < step5.length; i += 2) {\n    step6 += String.fromCharCode(parseInt(step5.substr(i, 2), 16));\n  }\n  // Step 5: Subtract 3 from character codes\n  let step7 = step6\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - 3))\n    .join(\"\");\n  // Step 6: Final case swap, reverse, and Base64 decode\n  let step8 = step7\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step9 = step8.split(\"\").reverse().join(\"\");\n  // return atob(step9);\n  let decodedUrl = atob(step9);\n  return decodedUrl;\n}\n",
    "turbovid": "\n/**\n * @name turbovidExtractor\n * @author Cufiy\n */\nasync function turbovidExtractor(html, url = null) {\n  const embedUrl = url;\n  // 1. Extract critical variables from embed page\n  const { mediaType, apKey, xxId } = await extractEmbedVariables(html);\n  console.log(\n    \"mediaType:\" + mediaType + \" | apKey:\" + apKey + \" | xxId:\" + xxId\n  );\n  // 2. Get decryption keys\n  const juiceKeys = await fetchJuiceKeys(embedUrl);\n  console.log(\"juiceKeys: \" + juiceKeys.juice);\n  // 3. Get encrypted video payload\n  const encryptedPayload = await fetchEncryptedPayload(embedUrl, apKey, xxId);\n \n  // 4. Decrypt and return final url\n  const streamUrl = xorDecryptHex(encryptedPayload, juiceKeys.juice);\n  console.log(\"streamUrl: \" + streamUrl);\n  // 5. Return the final stream URL\n  return streamUrl;\n}\n//   HELPERS\nasync function extractEmbedVariables(html) {\n  return {\n    mediaType: getJsVarValue(html, \"media_type\"),\n    // posterPath: getJsVarValue(html, 'posterPath'),\n    apKey: getJsVarValue(html, \"apkey\"),\n    dKey: getJsVarValue(html, \"dakey\"),\n    xxId: getJsVarValue(html, \"xxid\"),\n    xyId: getJsVarValue(html, \"xyid\"),\n  };\n}\nfunction getJsVarValue(html, varName) {\n  const regex = new RegExp(`const ${varName}\\\\s*=\\\\s*\"([^\"]+)`);\n  const match = html.match(regex);\n  return match ? match[1] : null;\n}\nasync function fetchJuiceKeys(embedUrl) {\n  // console.log(\"fetchJuiceKeys called with embedUrl:\", embedUrl);\n  // const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;\n  const fetchUrl =\n    atob(\"aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==\") + \"juice_key\";\n  // const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${fetchUrl}&headers=${headers} }`;\n  // const response = await fetch(vercelUrl);\n  const response = await fetch(fetchUrl, {\n    headers: {\n      method: \"GET\",\n      referer: embedUrl,\n    },\n  });\n  console.log(\"fetchJuiceKeys response:\", response.status);\n  // save entire response to file  \n  return await response.json() || await JSON.parse(response);\n}\nasync function fetchEncryptedPayload(embedUrl, apKey, xxId) {\n  const url =\n    atob(\"aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==\") +\n    \"the_juice_v2/?\" +\n    apKey +\n    \"=\" +\n    xxId;\n  console.log(\"url:\", url);\n  // const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;\n  // const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${url}&headers=${headers} }`;\n  // const response = await fetch(vercelUrl);\n  const response = await fetch(url, {\n    headers: {\n      method: \"GET\",\n      referer: embedUrl,\n    },\n  });\n  console.log(\"fetchEncryptedPayload response:\", response.status);\n  const data = await response.json() || await JSON.parse(response);\n  return data.data;\n}\nfunction xorDecryptHex(hexData, key) {\n  if (!hexData) {\n    throw new Error(\"hexData is undefined or null\");\n  }\n  const buffer = new Uint8Array(\n    hexData\n      .toString()\n      .match(/../g)\n      .map((h) => parseInt(h, 16))\n  );\n  let decrypted = \"\";\n  for (let i = 0; i < buffer.length; i++) {\n    const keyByte = key.charCodeAt(i % key.length);\n    decrypted += String.fromCharCode(buffer[i] ^ keyByte);\n  }\n  return decrypted;\n}\n",
    "vidoza": "\n/**\n * @name vidozaExtractor\n * @author Cufiy\n */\nasync function vidozaExtractor(html, url = null) {\n  const regex = /<source src=\"([^\"]+)\" type='video\\/mp4'>/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for vidoza extractor\");\n    return null;\n  }\n}\n",
    "voe": "\n/**\n * @name voeExtractor\n * @author Cufiy\n */\nfunction voeExtractor(html, url = null) {\n// Extract the first <script type=\"application/json\">...</script>\n    const jsonScriptMatch = html.match(\n      /<script[^>]+type=[\"']application\\/json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i\n    );\n    if (!jsonScriptMatch) {\n      console.log(\"No application/json script tag found\");\n      return null;\n    }\n\n    const obfuscatedJson = jsonScriptMatch[1].trim();\n  let data;\n  try {\n    data = JSON.parse(obfuscatedJson);\n  } catch (e) {\n    throw new Error(\"Invalid JSON input.\");\n  }\n  if (!Array.isArray(data) || typeof data[0] !== \"string\") {\n    throw new Error(\"Input doesn't match expected format.\");\n  }\n  let obfuscatedString = data[0];\n  // Step 1: ROT13\n  let step1 = voeRot13(obfuscatedString);\n  // Step 2: Remove patterns\n  let step2 = voeRemovePatterns(step1);\n  // Step 3: Base64 decode\n  let step3 = voeBase64Decode(step2);\n  // Step 4: Subtract 3 from each char code\n  let step4 = voeShiftChars(step3, 3);\n  // Step 5: Reverse string\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 6: Base64 decode again\n  let step6 = voeBase64Decode(step5);\n  // Step 7: Parse as JSON\n  let result;\n  try {\n    result = JSON.parse(step6);\n  } catch (e) {\n    throw new Error(\"Final JSON parse error: \" + e.message);\n  }\n  // console.log(\"Decoded JSON:\", result);\n  // check if direct_access_url is set, not null and starts with http\n  if (result && typeof result === \"object\") {\n    const streamUrl =\n      result.direct_access_url ||\n      result.source\n        .map((source) => source.direct_access_url)\n        .find((url) => url && url.startsWith(\"http\"));\n    if (streamUrl) {\n      console.log(\"Voe Stream URL: \" + streamUrl);\n      return streamUrl;\n    } else {\n      console.log(\"No stream URL found in the decoded JSON\");\n    }\n  }\n  return result;\n}\nfunction voeRot13(str) {\n  return str.replace(/[a-zA-Z]/g, function (c) {\n    return String.fromCharCode(\n      (c <= \"Z\" ? 90 : 122) >= (c = c.charCodeAt(0) + 13)\n        ? c\n        : c - 26\n    );\n  });\n}\nfunction voeRemovePatterns(str) {\n  const patterns = [\"@$\", \"^^\", \"~@\", \"%?\", \"*~\", \"!!\", \"#&\"];\n  let result = str;\n  for (const pat of patterns) {\n    result = result.split(pat).join(\"\");\n  }\n  return result;\n}\nfunction voeBase64Decode(str) {\n  // atob is available in browsers and Node >= 16\n  if (typeof atob === \"function\") {\n    return atob(str);\n  }\n  // Node.js fallback\n  return Buffer.from(str, \"base64\").toString(\"utf-8\");\n}\nfunction voeShiftChars(str, shift) {\n  return str\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - shift))\n    .join(\"\");\n}\n"
}