{
    "doodstream": "\n/**\n * @name doodstreamExtractor\n * @author Cufiy\n */\nasync function doodstreamExtractor(html, url = null) {\n    console.log(\"DoodStream extractor called\");\n    console.log(\"DoodStream extractor URL: \" + url);\n        const streamDomain = url.match(/https:\\/\\/(.*?)\\//, url)[0].slice(8, -1);\n        const md5Path = html.match(/'\\/pass_md5\\/(.*?)',/, url)[0].slice(11, -2);\n        const token = md5Path.substring(md5Path.lastIndexOf(\"/\") + 1);\n        const expiryTimestamp = new Date().valueOf();\n        const random = randomStr(10);\n\n        const passResponse = await fetch(`https://${streamDomain}/pass_md5/${md5Path}`, {\n            headers: {\n                \"Referer\": url,\n            },\n        });\n        console.log(\"DoodStream extractor response: \" + passResponse.status);\n        const responseData = await passResponse.text();\n        const videoUrl = `${responseData}${random}?token=${token}&expiry=${expiryTimestamp}`;\n        console.log(\"DoodStream extractor video URL: \" + videoUrl);\n        return videoUrl;\n}\nfunction randomStr(length) {\n    const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * characters.length));\n    }\n    return result;\n}\n",
    "speedfiles": "\n/**\n * @name speedfilesExtractor\n * @author Cufiy\n */\nfunction speedfilesExtractor(sourcePageHtml) {\n  // get var _0x5opu234 = \"THIS_IS_AN_ENCODED_STRING\"\n  const REGEX = /var\\s+_0x5opu234\\s*=\\s*\"([^\"]+)\"/;\n  const match = sourcePageHtml.match(REGEX);\n  if (match == null || match[1] == null) {\n    console.log(\"Could not extract from Speedfiles source\");\n    return null;\n  }\n  const encodedString = match[1];\n  console.log(\"Encoded String:\" + encodedString);\n  // Step 1: Base64 decode the initial string\n  let step1 = atob(encodedString);\n  // Step 2: Swap character cases and reverse\n  let step2 = step1\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step3 = step2.split(\"\").reverse().join(\"\");\n  // Step 3: Base64 decode again and reverse\n  let step4 = atob(step3);\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 4: Hex decode pairs\n  let step6 = \"\";\n  for (let i = 0; i < step5.length; i += 2) {\n    step6 += String.fromCharCode(parseInt(step5.substr(i, 2), 16));\n  }\n  // Step 5: Subtract 3 from character codes\n  let step7 = step6\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - 3))\n    .join(\"\");\n  // Step 6: Final case swap, reverse, and Base64 decode\n  let step8 = step7\n    .split(\"\")\n    .map((c) =>\n      /[a-zA-Z]/.test(c)\n        ? c === c.toLowerCase()\n          ? c.toUpperCase()\n          : c.toLowerCase()\n        : c\n    )\n    .join(\"\");\n  let step9 = step8.split(\"\").reverse().join(\"\");\n  // return atob(step9);\n  let decodedUrl = atob(step9);\n  return decodedUrl;\n}\n",
    "vidmoly": "\n/**\n * @name vidmolyExtractor\n * @author Ibro\n */\nasync function vidmolyExtractor(html, url = null) {\n  const regexSub = /<option value=\"([^\"]+)\"[^>]*>\\s*SUB - Omega\\s*<\\/option>/;\n  const regexFallback = /<option value=\"([^\"]+)\"[^>]*>\\s*Omega\\s*<\\/option>/;\n  const fallback =\n    /<option value=\"([^\"]+)\"[^>]*>\\s*SUB v2 - Omega\\s*<\\/option>/;\n  let match =\n    html.match(regexSub) || html.match(regexFallback) || html.match(fallback);\n  if (match) {\n    const decodedHtml = atob(match[1]); // Decode base64\n    const iframeMatch = decodedHtml.match(/<iframe\\s+src=\"([^\"]+)\"/);\n    if (!iframeMatch) {\n      console.log(\"Vidmoly extractor: No iframe match found\");\n      return null;\n    }\n    const streamUrl = iframeMatch[1].startsWith(\"//\")\n      ? \"https:\" + iframeMatch[1]\n      : iframeMatch[1];\n    const responseTwo = await fetchv2(streamUrl);\n    const htmlTwo = await responseTwo.text();\n    const m3u8Match = htmlTwo.match(/sources:\\s*\\[\\{file:\"([^\"]+\\.m3u8)\"/);\n    return m3u8Match ? m3u8Match[1] : null;\n  } else {\n    console.log(\"Vidmoly extractor: No match found, using fallback\");\n    //  regex the sources: [{file:\"this_is_the_link\"}]\n    const sourcesRegex = /sources:\\s*\\[\\{file:\"(https?:\\/\\/[^\"]+)\"\\}/;\n    const sourcesMatch = html.match(sourcesRegex);\n    let sourcesString = sourcesMatch\n      ? sourcesMatch[1].replace(/'/g, '\"')\n      : null;\n    return sourcesString;\n  }\n}\n",
    "voe": "\n/**\n * @name voeExtractor\n * @author Cufiy\n */\nfunction voeExtractor(html, url = null) {\n// Extract the first <script type=\"application/json\">...</script>\n    const jsonScriptMatch = html.match(\n      /<script[^>]+type=[\"']application\\/json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i\n    );\n    if (!jsonScriptMatch) {\n      console.log(\"No application/json script tag found\");\n      return null;\n    }\n\n    const obfuscatedJson = jsonScriptMatch[1].trim();\n  let data;\n  try {\n    data = JSON.parse(obfuscatedJson);\n  } catch (e) {\n    throw new Error(\"Invalid JSON input.\");\n  }\n  if (!Array.isArray(data) || typeof data[0] !== \"string\") {\n    throw new Error(\"Input doesn't match expected format.\");\n  }\n  let obfuscatedString = data[0];\n  // Step 1: ROT13\n  let step1 = voeRot13(obfuscatedString);\n  // Step 2: Remove patterns\n  let step2 = voeRemovePatterns(step1);\n  // Step 3: Base64 decode\n  let step3 = voeBase64Decode(step2);\n  // Step 4: Subtract 3 from each char code\n  let step4 = voeShiftChars(step3, 3);\n  // Step 5: Reverse string\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 6: Base64 decode again\n  let step6 = voeBase64Decode(step5);\n  // Step 7: Parse as JSON\n  let result;\n  try {\n    result = JSON.parse(step6);\n  } catch (e) {\n    throw new Error(\"Final JSON parse error: \" + e.message);\n  }\n  console.log(\"Decoded JSON:\", result);\n  // check if direct_access_url is set, not null and starts with http\n  if (result && typeof result === \"object\") {\n    const streamUrl =\n      result.direct_access_url ||\n      result.source\n        .map((source) => source.direct_access_url)\n        .find((url) => url && url.startsWith(\"http\"));\n    if (streamUrl) {\n      console.log(\"Voe Stream URL: \" + streamUrl);\n      return streamUrl;\n    } else {\n      console.log(\"No stream URL found in the decoded JSON\");\n    }\n  }\n  return result;\n}\nfunction voeRot13(str) {\n  return str.replace(/[a-zA-Z]/g, function (c) {\n    return String.fromCharCode(\n      (c <= \"Z\" ? 90 : 122) >= (c = c.charCodeAt(0) + 13)\n        ? c\n        : c - 26\n    );\n  });\n}\nfunction voeRemovePatterns(str) {\n  const patterns = [\"@$\", \"^^\", \"~@\", \"%?\", \"*~\", \"!!\", \"#&\"];\n  let result = str;\n  for (const pat of patterns) {\n    result = result.split(pat).join(\"\");\n  }\n  return result;\n}\nfunction voeBase64Decode(str) {\n  // atob is available in browsers and Node >= 16\n  if (typeof atob === \"function\") {\n    return atob(str);\n  }\n  // Node.js fallback\n  return Buffer.from(str, \"base64\").toString(\"utf-8\");\n}\nfunction voeShiftChars(str, shift) {\n  return str\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - shift))\n    .join(\"\");\n}\n"
}