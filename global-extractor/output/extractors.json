{
    "bigwarp": "\n/**\n * \n * @name bigWarpExtractor\n * @author Cufiy\n */\nasync function bigwarpExtractor(videoPage, url = null) {\n\n  // regex get 'sources: [{file:\"THIS_IS_THE_URL\" ... '\n  const scriptRegex = /sources:\\s*\\[\\{file:\"([^\"]+)\"/;\n  // const scriptRegex =\n  const scriptMatch = scriptRegex.exec(videoPage);\n  const bwDecoded = scriptMatch ? scriptMatch[1] : false;\n  console.log(\"BigWarp HD Decoded:\", bwDecoded);\n  return bwDecoded;\n}\n",
    "filemoon": "\n/**\n * @name filemoonExtractor\n * @author Cufiy - Inspired by Churly\n */\nasync function filemoonExtractor(html, url = null) {\n    // check if contains iframe, if does, extract the src and get the url\n    const regex = /<iframe[^>]+src=\"([^\"]+)\"[^>]*><\\/iframe>/;\n    const match = html.match(regex);\n    if (match) {\n        console.log(\"Iframe URL: \" + match[1]);\n        const iframeUrl = match[1];\n        const iframeResponse = await soraFetch(iframeUrl, {\n            headers: {\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\",\n                \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n            }\n        });\n        console.log(\"Iframe Response: \" + iframeResponse.status);\n        html = await iframeResponse.text();\n    }\n    // console.log(\"HTML: \" + html);\n    // get /<script[^>]*>([\\s\\S]*?)<\\/script>/gi\n    const scriptRegex = /<script[^>]*>([\\s\\S]*?)<\\/script>/gi;\n    const scripts = [];\n    let scriptMatch;\n    while ((scriptMatch = scriptRegex.exec(html)) !== null) {\n        scripts.push(scriptMatch[1]);\n    }\n    // get the script with eval and m3u8\n    const evalRegex = /eval\\((.*?)\\)/;\n    const m3u8Regex = /m3u8/;\n    // console.log(\"Scripts: \" + scripts);\n    const evalScript = scripts.find(script => evalRegex.test(script) && m3u8Regex.test(script));\n    if (!evalScript) {\n        console.log(\"No eval script found\");\n        return null;\n    }\n    const unpackedScript = unpack(evalScript);\n    // get the m3u8 url\n    const m3u8Regex2 = /https?:\\/\\/[^\\s]+master\\.m3u8[^\\s]*?(\\?[^\"]*)?/;\n    const m3u8Match = unpackedScript.match(m3u8Regex2);\n    if (m3u8Match) {\n        return m3u8Match[0];\n    } else {\n        console.log(\"No M3U8 URL found\");\n        return null;\n    }\n}\n\n",
    "mp4upload": "\n/**\n * @name mp4uploadExtractor\n * @author Cufiy\n */\nasync function mp4uploadExtractor(html, url = null) {\n    // src: \"https://a4.mp4upload.com:183/d/xkx3b4etz3b4quuo66rbmyqtjjoivahfxp27f35pti45rzapbvj5xwb4wuqtlpewdz4dirfp/video.mp4\"  \n    const regex = /src:\\s*\"([^\"]+)\"/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for mp4upload extractor\");\n    return null;\n  }\n}\n",
    "vidmoly": "\n/**\n * @name vidmolyExtractor\n * @author Ibro\n */\nasync function vidmolyExtractor(html, url = null) {\n  const regexSub = /<option value=\"([^\"]+)\"[^>]*>\\s*SUB - Omega\\s*<\\/option>/;\n  const regexFallback = /<option value=\"([^\"]+)\"[^>]*>\\s*Omega\\s*<\\/option>/;\n  const fallback =\n    /<option value=\"([^\"]+)\"[^>]*>\\s*SUB v2 - Omega\\s*<\\/option>/;\n  let match =\n    html.match(regexSub) || html.match(regexFallback) || html.match(fallback);\n  if (match) {\n    const decodedHtml = atob(match[1]); // Decode base64\n    const iframeMatch = decodedHtml.match(/<iframe\\s+src=\"([^\"]+)\"/);\n    if (!iframeMatch) {\n      console.log(\"Vidmoly extractor: No iframe match found\");\n      return null;\n    }\n    const streamUrl = iframeMatch[1].startsWith(\"//\")\n      ? \"https:\" + iframeMatch[1]\n      : iframeMatch[1];\n    const responseTwo = await fetchv2(streamUrl);\n    const htmlTwo = await responseTwo.text();\n    const m3u8Match = htmlTwo.match(/sources:\\s*\\[\\{file:\"([^\"]+\\.m3u8)\"/);\n    return m3u8Match ? m3u8Match[1] : null;\n  } else {\n    console.log(\"Vidmoly extractor: No match found, using fallback\");\n    //  regex the sources: [{file:\"this_is_the_link\"}]\n    const sourcesRegex = /sources:\\s*\\[\\{file:\"(https?:\\/\\/[^\"]+)\"\\}/;\n    const sourcesMatch = html.match(sourcesRegex);\n    let sourcesString = sourcesMatch\n      ? sourcesMatch[1].replace(/'/g, '\"')\n      : null;\n    return sourcesString;\n  }\n}\n",
    "vidoza": "\n/**\n * @name vidozaExtractor\n * @author Cufiy\n */\nasync function vidozaExtractor(html, url = null) {\n  const regex = /<source src=\"([^\"]+)\" type='video\\/mp4'>/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for vidoza extractor\");\n    return null;\n  }\n}\n",
    "voe": "\n/**\n * @name voeExtractor\n * @author Cufiy\n */\nfunction voeExtractor(html, url = null) {\n// Extract the first <script type=\"application/json\">...</script>\n    const jsonScriptMatch = html.match(\n      /<script[^>]+type=[\"']application\\/json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i\n    );\n    if (!jsonScriptMatch) {\n      console.log(\"No application/json script tag found\");\n      return null;\n    }\n\n    const obfuscatedJson = jsonScriptMatch[1].trim();\n  let data;\n  try {\n    data = JSON.parse(obfuscatedJson);\n  } catch (e) {\n    throw new Error(\"Invalid JSON input.\");\n  }\n  if (!Array.isArray(data) || typeof data[0] !== \"string\") {\n    throw new Error(\"Input doesn't match expected format.\");\n  }\n  let obfuscatedString = data[0];\n  // Step 1: ROT13\n  let step1 = voeRot13(obfuscatedString);\n  // Step 2: Remove patterns\n  let step2 = voeRemovePatterns(step1);\n  // Step 3: Base64 decode\n  let step3 = voeBase64Decode(step2);\n  // Step 4: Subtract 3 from each char code\n  let step4 = voeShiftChars(step3, 3);\n  // Step 5: Reverse string\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 6: Base64 decode again\n  let step6 = voeBase64Decode(step5);\n  // Step 7: Parse as JSON\n  let result;\n  try {\n    result = JSON.parse(step6);\n  } catch (e) {\n    throw new Error(\"Final JSON parse error: \" + e.message);\n  }\n  // console.log(\"Decoded JSON:\", result);\n  // check if direct_access_url is set, not null and starts with http\n  if (result && typeof result === \"object\") {\n    const streamUrl =\n      result.direct_access_url ||\n      result.source\n        .map((source) => source.direct_access_url)\n        .find((url) => url && url.startsWith(\"http\"));\n    if (streamUrl) {\n      console.log(\"Voe Stream URL: \" + streamUrl);\n      return streamUrl;\n    } else {\n      console.log(\"No stream URL found in the decoded JSON\");\n    }\n  }\n  return result;\n}\nfunction voeRot13(str) {\n  return str.replace(/[a-zA-Z]/g, function (c) {\n    return String.fromCharCode(\n      (c <= \"Z\" ? 90 : 122) >= (c = c.charCodeAt(0) + 13)\n        ? c\n        : c - 26\n    );\n  });\n}\nfunction voeRemovePatterns(str) {\n  const patterns = [\"@$\", \"^^\", \"~@\", \"%?\", \"*~\", \"!!\", \"#&\"];\n  let result = str;\n  for (const pat of patterns) {\n    result = result.split(pat).join(\"\");\n  }\n  return result;\n}\nfunction voeBase64Decode(str) {\n  // atob is available in browsers and Node >= 16\n  if (typeof atob === \"function\") {\n    return atob(str);\n  }\n  // Node.js fallback\n  return Buffer.from(str, \"base64\").toString(\"utf-8\");\n}\nfunction voeShiftChars(str, shift) {\n  return str\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - shift))\n    .join(\"\");\n}\n"
}