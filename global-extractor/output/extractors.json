{
    "bigwarp": "\n/**\n * \n * @name bigWarpExtractor\n * @author Cufiy\n */\nasync function bigwarpExtractor(videoPage, url = null) {\n\n  // regex get 'sources: [{file:\"THIS_IS_THE_URL\" ... '\n  const scriptRegex = /sources:\\s*\\[\\{file:\"([^\"]+)\"/;\n  // const scriptRegex =\n  const scriptMatch = scriptRegex.exec(videoPage);\n  const bwDecoded = scriptMatch ? scriptMatch[1] : false;\n  console.log(\"BigWarp HD Decoded:\", bwDecoded);\n  return bwDecoded;\n}\n",
    "doodstream": "\n/**\n * @name doodstreamExtractor\n * @author Cufiy\n */\nasync function doodstreamExtractor(html, url = null) {\n    console.log(\"DoodStream extractor called\");\n    console.log(\"DoodStream extractor URL: \" + url);\n        const streamDomain = url.match(/https:\\/\\/(.*?)\\//, url)[0].slice(8, -1);\n        const md5Path = html.match(/'\\/pass_md5\\/(.*?)',/, url)[0].slice(11, -2);\n        const token = md5Path.substring(md5Path.lastIndexOf(\"/\") + 1);\n        const expiryTimestamp = new Date().valueOf();\n        const random = randomStr(10);\n        const passResponse = await fetch(`https://${streamDomain}/pass_md5/${md5Path}`, {\n            headers: {\n                \"Referer\": url,\n            },\n        });\n        console.log(\"DoodStream extractor response: \" + passResponse.status);\n        const responseData = await passResponse.text();\n        const videoUrl = `${responseData}${random}?token=${token}&expiry=${expiryTimestamp}`;\n        console.log(\"DoodStream extractor video URL: \" + videoUrl);\n        return videoUrl;\n}\nfunction randomStr(length) {\n    const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * characters.length));\n    }\n    return result;\n}\n",
    "filemoon": "\n/* {REQUIRED PLUGINS: unbaser} */\n/**\n * @name filemoonExtractor\n * @author Cufiy - Inspired by Churly\n */\nasync function filemoonExtractor(html, url = null) {\n    // check if contains iframe, if does, extract the src and get the url\n    const regex = /<iframe[^>]+src=\"([^\"]+)\"[^>]*><\\/iframe>/;\n    const match = html.match(regex);\n    if (match) {\n        console.log(\"Iframe URL: \" + match[1]);\n        const iframeUrl = match[1];\n        const iframeResponse = await soraFetch(iframeUrl, {\n            headers: {\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\",\n                \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n                \"Referer\": url,\n            }\n        });\n        console.log(\"Iframe Response: \" + iframeResponse.status);\n        html = await iframeResponse.text();\n    }\n    // console.log(\"HTML: \" + html);\n    // get /<script[^>]*>([\\s\\S]*?)<\\/script>/gi\n    const scriptRegex = /<script[^>]*>([\\s\\S]*?)<\\/script>/gi;\n    const scripts = [];\n    let scriptMatch;\n    while ((scriptMatch = scriptRegex.exec(html)) !== null) {\n        scripts.push(scriptMatch[1]);\n    }\n    // get the script with eval and m3u8\n    const evalRegex = /eval\\((.*?)\\)/;\n    const m3u8Regex = /m3u8/;\n    // console.log(\"Scripts: \" + scripts);\n    const evalScript = scripts.find(script => evalRegex.test(script) && m3u8Regex.test(script));\n    if (!evalScript) {\n        console.log(\"No eval script found\");\n        return null;\n    }\n    const unpackedScript = unpack(evalScript);\n    // get the m3u8 url\n    const m3u8Regex2 = /https?:\\/\\/[^\\s]+master\\.m3u8[^\\s]*?(\\?[^\"]*)?/;\n    const m3u8Match = unpackedScript.match(m3u8Regex2);\n    if (m3u8Match) {\n        return m3u8Match[0];\n    } else {\n        console.log(\"No M3U8 URL found\");\n        return null;\n    }\n}\n\n\n",
    "megacloud": "\n/**\n * @name megacloudExtractor\n * @author ShadeOfChaos\n */\n\n// Megacloud V3 specific\nasync function megacloudExtractor(html, embedUrl) {\n\tconst CHARSET = Array.from({ length: 95 }, (_, i) => String.fromCharCode(i + 32));\n\tconst xraxParams = embedUrl.split('/').pop();\n\tconst xrax = xraxParams.includes('?') ? xraxParams.split('?')[0] : xraxParams;\n\tconst nonce = await getNonce(embedUrl);\n\t// return decrypt(secretKey, nonce, encryptedText);\n\ttry {\n\t\tconst response = await fetch(`https://megacloud.blog/embed-2/v3/e-1/getSources?id=${xrax}&_k=${nonce}`);\n\t\tconst rawSourceData = await response.json();\n\t\tconst encrypted = rawSourceData?.sources;\n\t\tlet decryptedSources = null;\n\t\tif (rawSourceData?.encrypted == false) {\n\t\t\tdecryptedSources = rawSourceData.sources;\n\t\t}\n\t\tif (decryptedSources == null) {\n\t\t\tdecryptedSources = await getDecryptedSourceV3(encrypted, nonce);\n\t\t\tif (!decryptedSources) throw new Error(\"Failed to decrypt source\");\n\t\t}\n\t\tconsole.log(\"Decrypted sources:\" + JSON.stringify(decryptedSources, null, 2));\n\t\t// return the first source if it's an array\n\t\tif (Array.isArray(decryptedSources) && decryptedSources.length > 0) {\n\t\t\ttry {\n\t\t\t\treturn decryptedSources[0].file;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.log(\"Error extracting MegaCloud stream URL:\" + error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// return {\n\t\t// \tstatus: true,\n\t\t// \tresult: {\n\t\t// \t\tsources: decryptedSources,\n\t\t// \t\ttracks: rawSourceData.tracks,\n\t\t// \t\tintro: rawSourceData.intro ?? null,\n\t\t// \t\toutro: rawSourceData.outro ?? null,\n\t\t// \t\tserver: rawSourceData.server ?? null\n\t\t// \t}\n\t\t// }\n\t} catch (error) {\n\t\tconsole.error(`[ERROR][decryptSources] Error decrypting ${embedUrl}:`, error);\n\t\treturn {\n\t\t\tstatus: false,\n\t\t\terror: error?.message || 'Failed to get HLS link'\n\t\t};\n\t}\n\t/**\n\t * Computes a key based on the given secret and nonce.\n\t * The key is used to \"unlock\" the encrypted data.\n\t * The computation of the key is based on the following steps:\n\t * 1. Concatenate the secret and nonce.\n\t * 2. Compute a hash value of the concatenated string using a simple\n\t *    hash function (similar to Java's String.hashCode()).\n\t * 3. Compute the remainder of the hash value divided by the maximum\n\t *    value of a 64-bit signed integer.\n\t * 4. Use the result as a XOR mask to process the characters of the\n\t *    concatenated string.\n\t * 5. Rotate the XOR-processed string by a shift amount equal to the\n\t *    hash value modulo the length of the XOR-processed string plus 5.\n\t * 6. Interleave the rotated string with the reversed nonce string.\n\t * 7. Take a substring of the interleaved string of length equal to 96\n\t *    plus the hash value modulo 33.\n\t * 8. Convert each character of the substring to a character code\n\t *    between 32 and 126 (inclusive) by taking the remainder of the\n\t *    character code divided by 95 and adding 32.\n\t * 9. Join the resulting array of characters into a string and return it.\n\t * @param {string} secret - The secret string\n\t * @param {string} nonce - The nonce string\n\t * @returns {string} The computed key\n\t */\n\tfunction computeKey(secret, nonce) {\n\t\tconst secretAndNonce = secret + nonce;\n\t\tlet hashValue = 0n;\n\t\tfor (const char of secretAndNonce) {\n\t\t\thashValue = BigInt(char.charCodeAt(0)) + hashValue * 31n + (hashValue << 7n) - hashValue;\n\t\t}\n\t\tconst maximum64BitSignedIntegerValue = 0x7fffffffffffffffn;\n\t\tconst hashValueModuloMax = hashValue % maximum64BitSignedIntegerValue;\n\t\tconst xorMask = 247;\n\t\tconst xorProcessedString = [...secretAndNonce]\n\t\t\t.map(char => String.fromCharCode(char.charCodeAt(0) ^ xorMask))\n\t\t\t.join('');\n\t\tconst xorLen = xorProcessedString.length;\n\t\tconst shiftAmount = (Number(hashValueModuloMax) % xorLen) + 5;\n\t\tconst rotatedString = xorProcessedString.slice(shiftAmount) + xorProcessedString.slice(0, shiftAmount);\n\t\tconst reversedNonceString = nonce.split('').reverse().join('');\n\t\tlet interleavedString = '';\n\t\tconst maxLen = Math.max(rotatedString.length, reversedNonceString.length);\n\t\tfor (let i = 0; i < maxLen; i++) {\n\t\t\tinterleavedString += (rotatedString[i] || '') + (reversedNonceString[i] || '');\n\t\t}\n\t\tconst length = 96 + (Number(hashValueModuloMax) % 33);\n\t\tconst partialString = interleavedString.substring(0, length);\n\t\treturn [...partialString]\n\t\t\t.map(ch => String.fromCharCode((ch.charCodeAt(0) % 95) + 32))\n\t\t\t.join('');\n\t}\n\t/**\n\t * Encrypts a given text using a columnar transposition cipher with a given key.\n\t * The function arranges the text into a grid of columns and rows determined by the key length,\n\t * fills the grid column by column based on the sorted order of the key characters,\n\t * and returns the encrypted text by reading the grid row by row.\n\t * \n\t * @param {string} text - The text to be encrypted.\n\t * @param {string} key - The key that determines the order of columns in the grid.\n\t * @returns {string} The encrypted text.\n\t */\n\tfunction columnarCipher(text, key) {\n\t\tconst columns = key.length;\n\t\tconst rows = Math.ceil(text.length / columns);\n\t\tconst grid = Array.from({ length: rows }, () => Array(columns).fill(''));\n\t\tconst columnOrder = [...key]\n\t\t\t.map((char, idx) => ({ char, idx }))\n\t\t\t.sort((a, b) => a.char.charCodeAt(0) - b.char.charCodeAt(0));\n\t\tlet i = 0;\n\t\tfor (const { idx } of columnOrder) {\n\t\t\tfor (let row = 0; row < rows; row++) {\n\t\t\t\tgrid[row][idx] = text[i++] || '';\n\t\t\t}\n\t\t}\n\t\treturn grid.flat().join('');\n\t}\n\t/**\n\t * Deterministically unshuffles an array of characters based on a given key phrase.\n\t * The function simulates a pseudo-random shuffling using a numeric seed derived\n\t * from the key phrase. This ensures that the same character array and key phrase\n\t * will always produce the same output, allowing for deterministic \"unshuffling\".\n\t * @param {Array} characters - The array of characters to unshuffle.\n\t * @param {string} keyPhrase - The key phrase used to generate the seed for the \n\t *                             pseudo-random number generator.\n\t * @returns {Array} A new array representing the deterministically unshuffled characters.\n\t */\n\tfunction deterministicUnshuffle(characters, keyPhrase) {\n\t\tlet seed = [...keyPhrase].reduce((acc, char) => (acc * 31n + BigInt(char.charCodeAt(0))) & 0xffffffffn, 0n);\n\t\tconst randomNumberGenerator = (upperLimit) => {\n\t\t\tseed = (seed * 1103515245n + 12345n) & 0x7fffffffn;\n\t\t\treturn Number(seed % BigInt(upperLimit));\n\t\t};\n\t\tconst shuffledCharacters = characters.slice();\n\t\tfor (let i = shuffledCharacters.length - 1; i > 0; i--) {\n\t\t\tconst j = randomNumberGenerator(i + 1);\n\t\t\t[shuffledCharacters[i], shuffledCharacters[j]] = [shuffledCharacters[j], shuffledCharacters[i]];\n\t\t}\n\t\treturn shuffledCharacters;\n\t}\n\t/**\n\t * Decrypts an encrypted text using a secret key and a nonce through multiple rounds of decryption.\n\t * The decryption process includes base64 decoding, character substitution using a pseudo-random \n\t * number generator, a columnar transposition cipher, and deterministic unshuffling of the character set.\n\t * Finally, it extracts and parses the decrypted JSON string or verifies it using a regex pattern.\n\t * \n\t * @param {string} secretKey - The key used to decrypt the text.\n\t * @param {string} nonce - A nonce for additional input to the decryption key.\n\t * @param {string} encryptedText - The text to be decrypted, encoded in base64.\n\t * @param {number} [rounds=3] - The number of decryption rounds to perform.\n\t * @returns {Object|null} The decrypted JSON object if successful, or null if parsing fails.\n\t */\n\tfunction decrypt(secretKey, nonce, encryptedText, rounds = 3) {\n\t\tlet decryptedText = Buffer.from(encryptedText, 'base64').toString('utf-8');\n\t\tconst keyPhrase = computeKey(secretKey, nonce);\n\t\tfor (let round = rounds; round >= 1; round--) {\n\t\t\tconst encryptionPassphrase = keyPhrase + round;\n\t\t\tlet seed = [...encryptionPassphrase].reduce((acc, char) => (acc * 31n + BigInt(char.charCodeAt(0))) & 0xffffffffn, 0n);\n\t\t\tconst randomNumberGenerator = (upperLimit) => {\n\t\t\t\tseed = (seed * 1103515245n + 12345n) & 0x7fffffffn;\n\t\t\t\treturn Number(seed % BigInt(upperLimit));\n\t\t\t};\n\t\t\tdecryptedText = [...decryptedText]\n\t\t\t\t.map(char => {\n\t\t\t\t\tconst charIndex = CHARSET.indexOf(char);\n\t\t\t\t\tif (charIndex === -1) return char;\n\t\t\t\t\tconst offset = randomNumberGenerator(95);\n\t\t\t\t\treturn CHARSET[(charIndex - offset + 95) % 95];\n\t\t\t\t})\n\t\t\t\t.join('');\n\t\t\tdecryptedText = columnarCipher(decryptedText, encryptionPassphrase);\n\t\t\tconst shuffledCharset = deterministicUnshuffle(CHARSET, encryptionPassphrase);\n\t\t\tconst mappingArr = {};\n\t\t\tshuffledCharset.forEach((c, i) => (mappingArr[c] = CHARSET[i]));\n\t\t\tdecryptedText = [...decryptedText].map(char => mappingArr[char] || char).join('');\n\t\t}\n\t\tconst lengthString = decryptedText.slice(0, 4);\n\t\tlet length = parseInt(lengthString, 10);\n\t\tif (isNaN(length) || length <= 0 || length > decryptedText.length - 4) {\n\t\t\tconsole.error('Invalid length in decrypted string');\n\t\t\treturn decryptedText;\n\t\t}\n\t\tconst decryptedString = decryptedText.slice(4, 4 + length);\n\t\ttry {\n\t\t\treturn JSON.parse(decryptedString);\n\t\t} catch (e) {\n\t\t\tconsole.warn('Could not parse decrypted string, unlikely to be valid. Using regex to verify');\n\t\t\tconst regex = /\"file\":\"(.*?)\".*?\"type\":\"(.*?)\"/;\n\t\t\tconst match = encryptedText.match(regex);\n\t\t\tconst matchedFile = match?.[1];\n\t\t\tconst matchType = match?.[2];\n\t\t\tif (!matchedFile || !matchType) {\n\t\t\t\tconsole.error('Could not match file or type in decrypted string');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn decryptedString;\n\t\t}\n\t}\n\t/**\n   * Tries to extract the MegaCloud nonce from the given embed URL.\n   * \n   * Fetches the HTML of the page, and tries to extract the nonce from it.\n   * If that fails, it sends a request with the \"x-requested-with\" header set to \"XMLHttpRequest\"\n   * and tries to extract the nonce from that HTML.\n   * \n   * If all else fails, it logs the HTML of both requests and returns null.\n   * \n   * @param {string} embedUrl The URL of the MegaCloud embed\n   * @returns {string|null} The extracted nonce, or null if it couldn't be found\n   */\n\tasync function getNonce(embedUrl) {\n\t\tconst res = await fetch(embedUrl, { headers: { \"referer\": \"https://anicrush.to/\", \"x-requested-with\": \"XMLHttpRequest\" } });\n\t\tconst html = await res.text();\n\t\tconst match0 = html.match(/\\<meta[\\s\\S]*?name=\"_gg_fb\"[\\s\\S]*?content=\"([\\s\\S]*?)\">/);\n\t\tif (match0?.[1]) {\n\t\t\treturn match0[1];\n\t\t}\n\t\tconst match1 = html.match(/_is_th:(\\S*?)\\s/);\n\t\tif (match1?.[1]) {\n\t\t\treturn match1[1];\n\t\t}\n\t\tconst match2 = html.match(/data-dpi=\"([\\s\\S]*?)\"/);\n\t\tif (match2?.[1]) {\n\t\t\treturn match2[1];\n\t\t}\n\t\tconst match3 = html.match(/_lk_db[\\s]?=[\\s\\S]*?x:[\\s]\"([\\S]*?)\"[\\s\\S]*?y:[\\s]\"([\\S]*?)\"[\\s\\S]*?z:[\\s]\"([\\S]*?)\"/);\n\t\tif (match3?.[1] && match3?.[2] && match3?.[3]) {\n\t\t\treturn \"\" + match3[1] + match3[2] + match3[3];\n\t\t}\n\t\tconst match4 = html.match(/nonce=\"([\\s\\S]*?)\"/);\n\t\tif (match4?.[1]) {\n\t\t\tif (match4[1].length >= 32) return match4[1];\n\t\t}\n\t\tconst match5 = html.match(/_xy_ws = \"(\\S*?)\"/);\n\t\tif (match5?.[1]) {\n\t\t\treturn match5[1];\n\t\t}\n\t\tconst match6 = html.match(/[a-zA-Z0-9]{48}]/);\n\t\tif (match6?.[1]) {\n\t\t\treturn match6[1];\n\t\t}\n\t\treturn null;\n\t}\n\tasync function getDecryptedSourceV3(encrypted, nonce) {\n\t\tlet decrypted = null;\n\t\tconst keys = await asyncGetKeys();\n\t\tfor(let key in keys) {\n\t\t\ttry {\n\t\t\t\tif (!encrypted) {\n\t\t\t\t\tconsole.log(\"Encrypted source missing in response\")\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tdecrypted = decrypt(keys[key], nonce, encrypted);\n\t\t\t\tif(!Array.isArray(decrypted) || decrypted.length <= 0) {\n\t\t\t\t\t// Failed to decrypt source\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(let source of decrypted) {\n\t\t\t\t\tif(source != null && source?.file?.startsWith('https://')) {\n\t\t\t\t\t\t// Malformed decrypted source\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(\"Functioning key:\", key);\n\t\t\t\treturn decrypted;\n\t\t\t} catch(error) {\n\t\t\t\tconsole.error('Error:', error);\n\t\t\t\tconsole.error(`[${ new Date().toLocaleString() }] Key did not work: ${ key }`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tasync function asyncGetKeys() {\n\t\tconst resolution = await Promise.allSettled([\n\t\t\tfetchKey(\"ofchaos\", \"https://ac-api.ofchaos.com/api/key\"),\n\t\t\tfetchKey(\"yogesh\", \"https://raw.githubusercontent.com/yogesh-hacker/MegacloudKeys/refs/heads/main/keys.json\"),\n\t\t\tfetchKey(\"esteven\", \"https://raw.githubusercontent.com/carlosesteven/e1-player-deobf/refs/heads/main/output/key.json\")\n\t\t]);\n\t\tconst keys = resolution.filter(r => r.status === 'fulfilled' && r.value != null).reduce((obj, r) => {\n\t\t\tlet rKey = Object.keys(r.value)[0];\n\t\t\tlet rValue = Object.values(r.value)[0];\n\t\t\tif (typeof rValue === 'string') {\n\t\t\t\tobj[rKey] = rValue.trim();\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tobj[rKey] = rValue?.mega ?? rValue?.decryptKey ?? rValue?.MegaCloud?.Anime?.Key ?? rValue?.megacloud?.key ?? rValue?.key ?? rValue?.megacloud?.anime?.key ?? rValue?.megacloud;\n\t\t\treturn obj;\n\t\t}, {});\n\t\tif (keys.length === 0) {\n\t\t\tthrow new Error(\"Failed to fetch any decryption key\");\n\t\t}\n\t\treturn keys;\n\t}\n\tfunction fetchKey(name, url, timeout = 1000) {\n\t\treturn new Promise(async (resolve) => {\n\t\t\ttry {\n\t\t\t\tconst response = await fetch(url, { method: 'get', timeout: timeout });\n\t\t\t\tconst key = await response.text();\n\t\t\t\tlet trueKey = null;\n\t\t\t\ttry {\n\t\t\t\t\ttrueKey = JSON.parse(key);\n\t\t\t\t} catch (e) {\n\t\t\t\t\ttrueKey = key;\n\t\t\t\t}\n\t\t\t\tresolve({ [name]: trueKey })\n\t\t\t} catch (error) {\n\t\t\t\tresolve(null);\n\t\t\t}\n\t\t});\n\t}\n}\n",
    "mp4upload": "\n/**\n * @name mp4uploadExtractor\n * @author Cufiy\n */\nasync function mp4uploadExtractor(html, url = null) {\n    // src: \"https://a4.mp4upload.com:183/d/xkx3b4etz3b4quuo66rbmyqtjjoivahfxp27f35pti45rzapbvj5xwb4wuqtlpewdz4dirfp/video.mp4\"  \n    const regex = /src:\\s*\"([^\"]+)\"/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for mp4upload extractor\");\n    return null;\n  }\n}\n",
    "sibnet": "\n/**\n * @name sibnetExtractor\n * @author scigward\n */\nasync function sibnetExtractor(html, embedUrl) {\n    try {\n        const videoMatch = html.match(\n            /player\\.src\\s*\\(\\s*\\[\\s*\\{\\s*src\\s*:\\s*[\"']([^\"']+)[\"']/i\n        );\n        if (!videoMatch || !videoMatch[1]) {\n            throw new Error(\"Sibnet video source not found\");\n        }\n        const videoPath = videoMatch[1];\n        const videoUrl = videoPath.startsWith(\"http\")\n            ? videoPath\n            : `https://video.sibnet.ru${videoPath}`;\n        return videoUrl;\n    } catch (error) {\n        console.log(\"SibNet extractor error: \" + error.message);\n        return null;\n    }\n}\n",
    "uqload": "\n/**\n * @name uqloadExtractor\n * @author scigward\n */\nasync function uqloadExtractor(html, embedUrl) {\n    try {\n        const match = html.match(/sources:\\s*\\[\\s*\"([^\"]+\\.mp4)\"\\s*\\]/);\n        const videoSrc = match ? match[1] : \"\";\n        return videoSrc;\n    } catch (error) {\n        console.log(\"uqloadExtractor error:\", error.message);\n        return null;\n    }\n}\n",
    "vidmoly": "\n/**\n * @name vidmolyExtractor\n * @author Ibro\n */\nasync function vidmolyExtractor(html, url = null) {\n  const regexSub = /<option value=\"([^\"]+)\"[^>]*>\\s*SUB - Omega\\s*<\\/option>/;\n  const regexFallback = /<option value=\"([^\"]+)\"[^>]*>\\s*Omega\\s*<\\/option>/;\n  const fallback =\n    /<option value=\"([^\"]+)\"[^>]*>\\s*SUB v2 - Omega\\s*<\\/option>/;\n  let match =\n    html.match(regexSub) || html.match(regexFallback) || html.match(fallback);\n  if (match) {\n    const decodedHtml = atob(match[1]); // Decode base64\n    const iframeMatch = decodedHtml.match(/<iframe\\s+src=\"([^\"]+)\"/);\n    if (!iframeMatch) {\n      console.log(\"Vidmoly extractor: No iframe match found\");\n      return null;\n    }\n    const streamUrl = iframeMatch[1].startsWith(\"//\")\n      ? \"https:\" + iframeMatch[1]\n      : iframeMatch[1];\n    const responseTwo = await fetchv2(streamUrl);\n    const htmlTwo = await responseTwo.text();\n    const m3u8Match = htmlTwo.match(/sources:\\s*\\[\\{file:\"([^\"]+\\.m3u8)\"/);\n    return m3u8Match ? m3u8Match[1] : null;\n  } else {\n    console.log(\"Vidmoly extractor: No match found, using fallback\");\n    //  regex the sources: [{file:\"this_is_the_link\"}]\n    const sourcesRegex = /sources:\\s*\\[\\{file:\"(https?:\\/\\/[^\"]+)\"\\}/;\n    const sourcesMatch = html.match(sourcesRegex);\n    let sourcesString = sourcesMatch\n      ? sourcesMatch[1].replace(/'/g, '\"')\n      : null;\n    return sourcesString;\n  }\n}\n",
    "vidoza": "\n/**\n * @name vidozaExtractor\n * @author Cufiy\n */\nasync function vidozaExtractor(html, url = null) {\n  const regex = /<source src=\"([^\"]+)\" type='video\\/mp4'>/;\n  const match = html.match(regex);\n  if (match) {\n    return match[1];\n  } else {\n    console.log(\"No match found for vidoza extractor\");\n    return null;\n  }\n}\n",
    "voe": "\n/**\n * @name voeExtractor\n * @author Cufiy\n */\nfunction voeExtractor(html, url = null) {\n// Extract the first <script type=\"application/json\">...</script>\n    const jsonScriptMatch = html.match(\n      /<script[^>]+type=[\"']application\\/json[\"'][^>]*>([\\s\\S]*?)<\\/script>/i\n    );\n    if (!jsonScriptMatch) {\n      console.log(\"No application/json script tag found\");\n      return null;\n    }\n\n    const obfuscatedJson = jsonScriptMatch[1].trim();\n  let data;\n  try {\n    data = JSON.parse(obfuscatedJson);\n  } catch (e) {\n    throw new Error(\"Invalid JSON input.\");\n  }\n  if (!Array.isArray(data) || typeof data[0] !== \"string\") {\n    throw new Error(\"Input doesn't match expected format.\");\n  }\n  let obfuscatedString = data[0];\n  // Step 1: ROT13\n  let step1 = voeRot13(obfuscatedString);\n  // Step 2: Remove patterns\n  let step2 = voeRemovePatterns(step1);\n  // Step 3: Base64 decode\n  let step3 = voeBase64Decode(step2);\n  // Step 4: Subtract 3 from each char code\n  let step4 = voeShiftChars(step3, 3);\n  // Step 5: Reverse string\n  let step5 = step4.split(\"\").reverse().join(\"\");\n  // Step 6: Base64 decode again\n  let step6 = voeBase64Decode(step5);\n  // Step 7: Parse as JSON\n  let result;\n  try {\n    result = JSON.parse(step6);\n  } catch (e) {\n    throw new Error(\"Final JSON parse error: \" + e.message);\n  }\n  // console.log(\"Decoded JSON:\", result);\n  // check if direct_access_url is set, not null and starts with http\n  if (result && typeof result === \"object\") {\n    const streamUrl =\n      result.direct_access_url ||\n      result.source\n        .map((source) => source.direct_access_url)\n        .find((url) => url && url.startsWith(\"http\"));\n    if (streamUrl) {\n      console.log(\"Voe Stream URL: \" + streamUrl);\n      return streamUrl;\n    } else {\n      console.log(\"No stream URL found in the decoded JSON\");\n    }\n  }\n  return result;\n}\nfunction voeRot13(str) {\n  return str.replace(/[a-zA-Z]/g, function (c) {\n    return String.fromCharCode(\n      (c <= \"Z\" ? 90 : 122) >= (c = c.charCodeAt(0) + 13)\n        ? c\n        : c - 26\n    );\n  });\n}\nfunction voeRemovePatterns(str) {\n  const patterns = [\"@$\", \"^^\", \"~@\", \"%?\", \"*~\", \"!!\", \"#&\"];\n  let result = str;\n  for (const pat of patterns) {\n    result = result.split(pat).join(\"\");\n  }\n  return result;\n}\nfunction voeBase64Decode(str) {\n  // atob is available in browsers and Node >= 16\n  if (typeof atob === \"function\") {\n    return atob(str);\n  }\n  // Node.js fallback\n  return Buffer.from(str, \"base64\").toString(\"utf-8\");\n}\nfunction voeShiftChars(str, shift) {\n  return str\n    .split(\"\")\n    .map((c) => String.fromCharCode(c.charCodeAt(0) - shift))\n    .join(\"\");\n}\n"
}