/* Replace your extractStreamUrl function with the script below */

/**
 * @name global_extractor.js
 * @description Global extractor to be used in Sora Modules
 * @author Cufiy
 * @license MIT
 * @date 2025-05-03 18:11:20
 * @note This file is automatically generated.
 */


async function extractStreamUrl(url) {
  try {
    let providers = {};

    // Logic to populate providers
    // ...
    // Note: The higher up the provider is in the list, the higher the priority
    // Available providers: bigwarp, speedfiles, turbovid, vidmoly


    // E.g.
    // providers = {
    //   "https://vidmoly.to/embed-preghvoypr2m.html": "vidmoly",
    //   "https://speedfiles.net/40d98cdccf9c": "speedfiles",
    //   "https://speedfiles.net/82346fs": "speedfiles",
    // };


    let streamUrl = null;
    try {
      streamUrl = globalExtractor(providers);
    } catch (error) {
      console.log("Global extractor error:" + error);
      return null;
    }


    if (!streamUrl) {
      throw new Error("Stream URL not found");
    }
    return streamUrl;
  } catch (error) {
    console.log("Fetch error:", error);
    return null;
  }
}

function globalExtractor(providers) {
  for (const [url, provider] of Object.entries(providers)) {
    try {
      const streamUrl = extractStreamUrlByProvider(url, provider);
      if (streamUrl) {
        return streamUrl;
      }
    } catch (error) {
      // Ignore the error and try the next provider
    }
  }
  return null;
}


async function extractStreamUrlByProvider(url, provider) {
  // fetch the url
  // and pass the response to the extractor function
  console.log("Fetching URL: " + url);
  const response = await fetch(url);
  console.log("Response: " + response.status);
  const html = response.text ? await response.text() : response;
  // console.log("HTML: " + html);
  switch (provider) {
    case "bigwarp":
      return await bigwarpExtractor(html);
    case "speedfiles":
      return await speedfilesExtractor(html);
    case "turbovid":
      return await turbovidExtractor(html);
    case "vidmoly":
      return await vidmolyExtractor(html);

    default:
      throw new Error(`Unknown provider: ${provider}`);
  }
}




////////////////////////////////////////////////
//                 EXTRACTORS                 //
////////////////////////////////////////////////

// DO NOT EDIT BELOW THIS LINE UNLESS YOU KNOW WHAT YOU ARE DOING //


/* --- bigwarp --- */

/**
 * 
 * @name bigWarpExtractor
 * @author Cufiy
 */
async function bigwarpExtractor(html) {
  console.log("BigWarp HD extraction method");
  const bwRegex =
    /<ul class="currentStreamLinks"[\s\S]*?<p class="hostName">BigWarp HD<\/p>[\s\S]*?<a[^>]+class="button rb iconPlay"[^>]+href="([^"]+)"[^>]*>/;
  const bwMatch = bwRegex.exec(html);
  if (!bwMatch || !bwMatch[1]) {
    console.log("BigWarp HD stream URL not found");
    return false;
  }
  let bwUrl = bwMatch[1];
  console.log("BigWarp URL:", bwUrl);
  const videoPage = await fetch(bwUrl);
  const scriptRegex =
    /jwplayer\("vplayer"\)\.setup\(\{[\s\S]*?sources:\s*\[\{file:"([^"]+)",label:"[^"]+"\}\]/;
  const scriptMatch = scriptRegex.exec(videoPage);
  const bwDecoded = scriptMatch ? scriptMatch[1] : false;
  console.log("BigWarp HD Decoded:", bwDecoded);
  return bwDecoded;
}


/* --- speedfiles --- */

/**
 * @name speedfilesExtractor
 * @author Cufiy
 */
function speedfilesExtractor(sourcePageHtml) {
  // get var _0x5opu234 = "THIS_IS_AN_ENCODED_STRING"
  const REGEX = /var\s+_0x5opu234\s*=\s*"([^"]+)"/;
  const match = sourcePageHtml.match(REGEX);
  if (match == null || match[1] == null) {
    console.log("Could not extract from Speedfiles source");
    return null;
  }
  const encodedString = match[1];
  console.log("Encoded String:" + encodedString);
  // Step 1: Base64 decode the initial string
  let step1 = atob(encodedString);
  // Step 2: Swap character cases and reverse
  let step2 = step1
    .split("")
    .map((c) =>
      /[a-zA-Z]/.test(c)
        ? c === c.toLowerCase()
          ? c.toUpperCase()
          : c.toLowerCase()
        : c
    )
    .join("");
  let step3 = step2.split("").reverse().join("");
  // Step 3: Base64 decode again and reverse
  let step4 = atob(step3);
  let step5 = step4.split("").reverse().join("");
  // Step 4: Hex decode pairs
  let step6 = "";
  for (let i = 0; i < step5.length; i += 2) {
    step6 += String.fromCharCode(parseInt(step5.substr(i, 2), 16));
  }
  // Step 5: Subtract 3 from character codes
  let step7 = step6
    .split("")
    .map((c) => String.fromCharCode(c.charCodeAt(0) - 3))
    .join("");
  // Step 6: Final case swap, reverse, and Base64 decode
  let step8 = step7
    .split("")
    .map((c) =>
      /[a-zA-Z]/.test(c)
        ? c === c.toLowerCase()
          ? c.toUpperCase()
          : c.toLowerCase()
        : c
    )
    .join("");
  let step9 = step8.split("").reverse().join("");
  // return atob(step9);
  let decodedUrl = atob(step9);
  return decodedUrl;
}


/* --- turbovid --- */

/**
 * @name turbovidExtractor
 * @author Cufiy
 */
async function turbovidExtractor(html) {
  const base64EmbedUrl = html.match(/main_origin = "([^"]+)"/)[1];
  const embedUrl = atob(base64EmbedUrl);
  // 1. Extract critical variables from embed page
  const { mediaType, apKey, xxId } = await extractEmbedVariables(embedUrl);
  console.log(
    "mediaType:" + mediaType + " | apKey:" + apKey + " | xxId:" + xxId
  );
  // 2. Get decryption keys
  const juiceKeys = await fetchJuiceKeys(embedUrl);
  console.log("juiceKeys: " + juiceKeys.juice);
  // 3. Get encrypted video payload
  const encryptedPayload = await fetchEncryptedPayload(embedUrl, apKey, xxId);
 
  // 4. Decrypt and return final url
  const streamUrl = xorDecryptHex(encryptedPayload, juiceKeys.juice);
  console.log("streamUrl: " + streamUrl);
  // 5. Return the final stream URL
  if (mediaType === "video") {
    return streamUrl;
  } else {
    console.log("Media type is not video");
    return null;
  }
}
//   HELPERS
async function extractEmbedVariables(embedUrl) {
  const response = await fetch(embedUrl);
  // const html = await response.text();
  const html = await response;
  return {
    mediaType: getJsVarValue(html, "media_type"),
    // posterPath: getJsVarValue(html, 'posterPath'),
    apKey: getJsVarValue(html, "apkey"),
    dKey: getJsVarValue(html, "dakey"),
    xxId: getJsVarValue(html, "xxid"),
    xyId: getJsVarValue(html, "xyid"),
  };
}
async function fetchJuiceKeys(embedUrl) {
  const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;
  const fetchUrl =
    atob("aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==") + "juice_key";
  const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${fetchUrl}&headers=${headers} }`;
  const response = await fetch(vercelUrl);
  return await JSON.parse(response);
}
async function fetchEncryptedPayload(embedUrl, apKey, xxId) {
  const url =
    atob("aHR0cHM6Ly90dXJib3ZpZC5ldS9hcGkvY3Vja2VkLw==") +
    "the_juice_v2/?" +
    apKey +
    "=" +
    xxId;
  console.log("url:", url);
  const headers = `Referer=${embedUrl}|Origin=${embedUrl}`;
  const vercelUrl = `https://sora-passthrough.vercel.app/passthrough?url=${url}&headers=${headers} }`;
  const response = await fetch(vercelUrl);
  const data = await JSON.parse(response);
  return data.data;
}
function xorDecryptHex(hexData, key) {
  if (!hexData) {
    throw new Error("hexData is undefined or null");
  }
  const buffer = new Uint8Array(
    hexData
      .toString()
      .match(/../g)
      .map((h) => parseInt(h, 16))
  );
  let decrypted = "";
  for (let i = 0; i < buffer.length; i++) {
    const keyByte = key.charCodeAt(i % key.length);
    decrypted += String.fromCharCode(buffer[i] ^ keyByte);
  }
  return decrypted;
}


/* --- vidmoly --- */

/**
 * @name vidmolyExtractor
 * @author Ibro
 */
async function vidmolyExtractor(html) {
  const regexSub = /<option value="([^"]+)"[^>]*>\s*SUB - Omega\s*<\/option>/;
  const regexFallback = /<option value="([^"]+)"[^>]*>\s*Omega\s*<\/option>/;
  const fallback =
    /<option value="([^"]+)"[^>]*>\s*SUB v2 - Omega\s*<\/option>/;
  let match =
    html.match(regexSub) || html.match(regexFallback) || html.match(fallback);
  if (match) {
    const decodedHtml = atob(match[1]); // Decode base64
    const iframeMatch = decodedHtml.match(/<iframe\s+src="([^"]+)"/);
    if (!iframeMatch) {
      console.log("Vidmoly extractor: No iframe match found");
      return null;
    }
    const streamUrl = iframeMatch[1].startsWith("//")
      ? "https:" + iframeMatch[1]
      : iframeMatch[1];
    const responseTwo = await fetchv2(streamUrl);
    const htmlTwo = await responseTwo.text();
    const m3u8Match = htmlTwo.match(/sources:\s*\[\{file:"([^"]+\.m3u8)"/);
    return m3u8Match ? m3u8Match[1] : null;
  } else {
    console.log("Vidmoly extractor: No match found, using fallback");
    //  regex the sources: [{file:"this_is_the_link"}]
    const sourcesRegex = /sources:\s*\[\{file:"(https?:\/\/[^"]+)"\}/;
    const sourcesMatch = html.match(sourcesRegex);
    let sourcesString = sourcesMatch
      ? sourcesMatch[1].replace(/'/g, '"')
      : null;
    return sourcesString;
  }
}


